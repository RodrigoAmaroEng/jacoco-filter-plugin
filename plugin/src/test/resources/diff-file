diff --git a/app/build.gradle b/app/build.gradle
index 47300cd..62a1f9d 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -3,6 +3,7 @@ apply plugin: 'kotlin-android'
 apply plugin: 'kotlin-android-extensions'
 apply plugin: 'jacoco'
 apply plugin: 'com.getkeepsafe.dexcount'
+apply from: '../version.gradle'
 
 jacoco {
     toolVersion = '0.8.2'
@@ -22,8 +23,6 @@ android {
         applicationId "br.eng.rodrigoamaro.architectureplayground"
         minSdkVersion 15
         targetSdkVersion 28
-        versionCode 1
-        versionName "1.0"
         testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
     buildTypes {
@@ -31,7 +30,8 @@ android {
             testCoverageEnabled true
         }
         release {
-            minifyEnabled false
+            shrinkResources true
+            minifyEnabled true
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
@@ -62,6 +62,8 @@ dependencies {
     implementation 'com.jakewharton.rxrelay2:rxrelay:2.1.0'
     implementation 'com.jakewharton.rxbinding2:rxbinding-appcompat-v7:2.1.1'
     implementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'
+    implementation 'com.squareup.retrofit2:converter-wire:2.4.0'
+    implementation 'com.squareup.wire:wire-runtime:2.3.0-RC1'
     testImplementation 'io.mockk:mockk:1.8.12.kotlin13'
     androidTestImplementation 'androidx.test.ext:junit:1.0.0'
     androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0'
@@ -93,4 +95,4 @@ task jacocoTestReport(type: JacocoReport, dependsOn: ['connectedAndroidTest', 'c
 tasks.withType(Test) {
     jacoco.includeNoLocationClasses = true
 }
-apply from: '../syntax.gradle'
\ No newline at end of file
+apply from: '../syntax.gradle'
diff --git a/app/proguard-rules.pro b/app/proguard-rules.pro
index f1b4245..cb78d3d 100644
--- a/app/proguard-rules.pro
+++ b/app/proguard-rules.pro
@@ -1,21 +1,70 @@
-# Add project specific ProGuard rules here.
-# You can control the set of applied configuration files using the
-# proguardFiles setting in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
-#-renamesourcefileattribute SourceFile
+####################################
+# RETROFIT - https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
+####################################
+# Retrofit does reflection on generic parameters. InnerClasses is required to use Signature and
+# EnclosingMethod is required to use InnerClasses.
+-keepattributes Signature, InnerClasses, EnclosingMethod
+
+# Retain service method parameters when optimizing.
+-keepclassmembers,allowshrinking,allowobfuscation interface * {
+    @retrofit2.http.* <methods>;
+}
+
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+
+# Ignore JSR 305 annotations for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# Guarded by a NoClassDefFoundError try/catch and only used when on the classpath.
+-dontwarn kotlin.Unit
+
+# Top-level functions that can only be used by Kotlin.
+-dontwarn retrofit2.-KotlinExtensions
+
+####################################
+# KOIN - https://github.com/InsertKoinIO/getting-started-koin-android/blob/master/proguard-rules.pro
+####################################
+
+# This is a configuration file for ProGuard.
+# http://proguard.sourceforge.net/index.html#manual/usage.html
+-dontusemixedcaseclassnames
+-dontskipnonpubliclibraryclasses
+-verbose
+
+####################################
+# COROUTINES - https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/kotlinx-coroutines-android/example-app/app/proguard-rules.pro
+####################################
+
+-keepnames class kotlinx.coroutines.internal.MainDispatcherFactory {}
+-keepnames class kotlinx.coroutines.CoroutineExceptionHandler {}
+-keepclassmembernames class kotlinx.** {
+    volatile <fields>;
+}
+
+####################################
+# ANDROID ARCHITECTURE COMPONENTS - https://issuetracker.google.com/issues/62113696
+####################################
+-keep class * implements android.arch.lifecycle.LifecycleObserver {
+    <init>(...);
+}
+
+# ViewModel's empty constructor is considered to be unused by proguard
+-keepclassmembers class * extends android.arch.lifecycle.ViewModel {
+    <init>(...);
+}
+
+# keep Lifecycle State and Event enums values
+-keepclassmembers class android.arch.lifecycle.Lifecycle$State { *; }
+-keepclassmembers class android.arch.lifecycle.Lifecycle$Event { *; }
+# keep methods annotated with @OnLifecycleEvent even if they seem to be unused
+# (Mostly for LiveData.LifecycleBoundObserver.onStateChange(), but who knows)
+-keepclassmembers class * {
+    @android.arch.lifecycle.OnLifecycleEvent *;
+}
+
+####################################
+# WIRE - https://github.com/square/wire
+####################################
+-keep class com.squareup.wire.** { *; }
+-keep class com.yourcompany.yourgeneratedcode.** { *; }
\ No newline at end of file
diff --git a/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/CoffeeBuyerRobot.kt b/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/CoffeeBuyerRobot.kt
index 584c129..5f567ea 100644
--- a/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/CoffeeBuyerRobot.kt
+++ b/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/CoffeeBuyerRobot.kt
@@ -48,8 +48,8 @@ class SaleResult {
         onView(withText("R$ $price")).check(matches(isDisplayed()))
     }
 
-    fun transactionSucceeded() {
-        onView(withText("Transação concluída!")).check(matches(isDisplayed()))
+    fun transactionSucceeded(orderNumber: String) {
+        onView(withText("Transação '$orderNumber' concluída!")).check(matches(isDisplayed()))
     }
 
     fun transactionNotSucceeded() {
diff --git a/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/EnvironmentSetup.kt b/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/EnvironmentSetup.kt
index 812c948..6421db6 100644
--- a/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/EnvironmentSetup.kt
+++ b/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/EnvironmentSetup.kt
@@ -3,6 +3,7 @@ package br.eng.rodrigoamaro.architectureplayground
 import android.content.Context
 import android.preference.PreferenceManager
 import androidx.test.espresso.IdlingRegistry
+import br.eng.rodrigoamaro.architectureplayground.coffee.proto.Receipt
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.GlobalScope
 import kotlinx.coroutines.Job
@@ -26,10 +27,14 @@ class EnvironmentSetup(private val context: Context) {
     }
 
     fun setSuccessServiceResponse() {
+        val receipt = Receipt.Builder()
+            .amount(300)
+            .orderNumber("1234")
+            .build()
         dispatcher.queue.add(
-            MockResponse().setBody("{\"orderNumber\":\"1234\"}").setResponseCode(
-                200
-            )
+            MockResponse()
+                .setBody(String(receipt.encode()))
+                .setResponseCode(200)
         )
     }
 
diff --git a/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/ExampleInstrumentedTest.kt b/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/ExampleInstrumentedTest.kt
index 250d64c..b7085a6 100644
--- a/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/ExampleInstrumentedTest.kt
+++ b/app/src/androidTest/java/br/eng/rodrigoamaro/architectureplayground/ExampleInstrumentedTest.kt
@@ -57,7 +57,7 @@ class ExampleInstrumentedTest {
             .finishOrder()
             .selectPaymentMethod(CoffeeBuyerRobot.PaymentMethod.Debit)
             .check()
-            .transactionSucceeded()
+            .transactionSucceeded("1234")
     }
 
     @Test
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/MyApplication.kt b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/MyApplication.kt
index 36b2996..eb3dd67 100644
--- a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/MyApplication.kt
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/MyApplication.kt
@@ -11,14 +11,14 @@ import org.koin.android.ext.android.startKoin
 import org.koin.dsl.module.module
 import org.koin.standalone.StandAloneContext.stopKoin
 import retrofit2.Retrofit
-import retrofit2.converter.moshi.MoshiConverterFactory
+import retrofit2.converter.wire.WireConverterFactory
 
 class MyApplication : Application() {
     private val module = module(override = true) {
         single<Api> {
             Retrofit.Builder()
                 .baseUrl("http://localhost:8080/")
-                .addConverterFactory(MoshiConverterFactory.create())
+                .addConverterFactory(WireConverterFactory.create())
                 .addCallAdapterFactory(CoroutineCallAdapterFactory())
                 .build().create(Api::class.java)
         }
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/Actions.kt b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/Actions.kt
index 7e0560f..4b25f3e 100644
--- a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/Actions.kt
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/Actions.kt
@@ -13,7 +13,7 @@ data class NavigateAction(@IdRes val destination: Int) : Action()
 object SetCoffeesAction : Action()
 
 data class PayAction(val method: Methods) : Action()
-object PayCompletedAction : Action()
+data class PayCompletedAction(val orderNumber: String?) : Action()
 object PayFailedAction : Action()
 
 object NewSaleAction : Action()
\ No newline at end of file
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/Api.kt b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/Api.kt
index 6fe359e..7563d8d 100644
--- a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/Api.kt
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/Api.kt
@@ -1,5 +1,6 @@
 package br.eng.rodrigoamaro.architectureplayground.coffee
 
+import br.eng.rodrigoamaro.architectureplayground.coffee.proto.Receipt
 import kotlinx.coroutines.Deferred
 import retrofit2.Response
 import retrofit2.http.GET
@@ -7,6 +8,4 @@ import retrofit2.http.GET
 interface Api {
     @GET("/coffee/pay")
     fun payForCoffee(): Deferred<Response<Receipt>>
-}
-
-class Receipt(val orderNumber: String)
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentMiddleware.kt b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentMiddleware.kt
index ae51054..57adb4f 100644
--- a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentMiddleware.kt
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentMiddleware.kt
@@ -13,8 +13,8 @@ class PaymentMiddleware(
         if (action is PayAction) {
             launcher.launchThis {
                 try {
-                    service.pay(state!!)
-                    dispatcher.dispatch(PayCompletedAction)
+                    val receipt = service.pay(state!!)
+                    dispatcher.dispatch(PayCompletedAction(receipt?.orderNumber))
                 } catch (ex: Throwable) {
                     ex.printStackTrace()
                     dispatcher.dispatch(PayFailedAction)
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentReducer.kt b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentReducer.kt
index 7f367fe..ee6e5f3 100644
--- a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentReducer.kt
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentReducer.kt
@@ -8,7 +8,10 @@ class PaymentReducer : Reducer<SaleState> {
     override fun reduce(action: Action, state: SaleState): SaleState {
         return when (action) {
             is PayAction -> state.copy(status = Status.PROCESSING)
-            PayCompletedAction -> state.copy(status = Status.COMPLETED)
+            is PayCompletedAction -> state.copy(
+                status = Status.COMPLETED,
+                orderNumber = action.orderNumber
+            )
             PayFailedAction -> state.copy(status = Status.FAILED)
             NewSaleAction -> SaleState(Money("R$"), 0)
             else -> state
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentService.kt b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentService.kt
index b9577c5..d066e94 100644
--- a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentService.kt
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/PaymentService.kt
@@ -1,14 +1,18 @@
 package br.eng.rodrigoamaro.architectureplayground.coffee
 
+import br.eng.rodrigoamaro.architectureplayground.coffee.proto.Receipt
+
 interface PaymentService {
-    suspend fun pay(invoice: SaleState)
+    suspend fun pay(invoice: SaleState): Receipt?
 }
 
 class PaymentServiceImpl(private val api: Api) : PaymentService {
-    override suspend fun pay(invoice: SaleState) {
+    override suspend fun pay(invoice: SaleState): Receipt? {
         val result = api.payForCoffee().await()
         if (!result.isSuccessful) {
             throw IllegalStateException()
+        } else {
+            return result.body()
         }
     }
 }
\ No newline at end of file
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/ProcessingInteractor.kt b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/ProcessingInteractor.kt
index f965033..32a1431 100644
--- a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/ProcessingInteractor.kt
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/ProcessingInteractor.kt
@@ -21,7 +21,7 @@ class ProcessingInteractor(store: Store<SaleState>, view: View, private val view
     override fun accept(state: SaleState) {
         viewState.currentState = state
         if (state.status == Status.COMPLETED)
-            success()
+            success(state.orderNumber)
         else if (state.status == Status.FAILED)
             fail()
     }
@@ -31,8 +31,9 @@ class ProcessingInteractor(store: Store<SaleState>, view: View, private val view
         imageStatus.setImageResource(R.drawable.fail)
     }
 
-    private fun success() {
-        textStatus.setText(R.string.transaction_suceeded)
+    private fun success(orderNumber: String?) {
+        val text = imageStatus.resources.getText(R.string.transaction_suceeded).toString()
+        textStatus.text = String.format(text, orderNumber)
         imageStatus.setImageResource(R.drawable.success)
     }
 }
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/SaleState.kt b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/SaleState.kt
index c529a86..1c17d31 100644
--- a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/SaleState.kt
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/SaleState.kt
@@ -7,7 +7,8 @@ import br.eng.rodrigoamaro.architectureplayground.redux.State
 data class SaleState(
     val amount: Money = money { currency = "R$" },
     val coffees: Int = 0,
-    val status: Status = Status.READY_TO_SALE
+    val status: Status = Status.READY_TO_SALE,
+    val orderNumber: String? = null
 ) : State
 
 enum class Status {
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/proto/Receipt.java b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/proto/Receipt.java
new file mode 100644
index 0000000..8f1e913
--- /dev/null
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/proto/Receipt.java
@@ -0,0 +1,164 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: receipt.proto
+package br.eng.rodrigoamaro.architectureplayground.coffee.proto;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+
+import okio.ByteString;
+
+public final class Receipt extends Message<Receipt, Receipt.Builder> {
+    public static final ProtoAdapter<Receipt> ADAPTER = new ProtoAdapter_Receipt();
+    public static final String DEFAULT_ORDERNUMBER = "";
+    public static final Integer DEFAULT_AMOUNT = 0;
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String orderNumber;
+
+    @WireField(
+            tag = 2,
+            adapter = "com.squareup.wire.ProtoAdapter#INT32"
+    )
+    public final Integer amount;
+
+    public Receipt(String orderNumber, Integer amount) {
+        this(orderNumber, amount, ByteString.EMPTY);
+    }
+
+    public Receipt(String orderNumber, Integer amount, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.orderNumber = orderNumber;
+        this.amount = amount;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.orderNumber = orderNumber;
+        builder.amount = amount;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+      if (other == this) {
+        return true;
+      }
+      if (!(other instanceof Receipt)) {
+        return false;
+      }
+        Receipt o = (Receipt) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(orderNumber, o.orderNumber)
+                && Internal.equals(amount, o.amount);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (orderNumber != null ? orderNumber.hashCode() : 0);
+            result = result * 37 + (amount != null ? amount.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+      if (orderNumber != null) {
+        builder.append(", orderNumber=").append(orderNumber);
+      }
+      if (amount != null) {
+        builder.append(", amount=").append(amount);
+      }
+        return builder.replace(0, 2, "Receipt{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<Receipt, Builder> {
+        public String orderNumber;
+
+        public Integer amount;
+
+        public Builder() {
+        }
+
+        public Builder orderNumber(String orderNumber) {
+            this.orderNumber = orderNumber;
+            return this;
+        }
+
+        public Builder amount(Integer amount) {
+            this.amount = amount;
+            return this;
+        }
+
+        @Override
+        public Receipt build() {
+            return new Receipt(orderNumber, amount, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_Receipt extends ProtoAdapter<Receipt> {
+        public ProtoAdapter_Receipt() {
+            super(FieldEncoding.LENGTH_DELIMITED, Receipt.class);
+        }
+
+        @Override
+        public int encodedSize(Receipt value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.orderNumber)
+                    + ProtoAdapter.INT32.encodedSizeWithTag(2, value.amount)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, Receipt value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.orderNumber);
+            ProtoAdapter.INT32.encodeWithTag(writer, 2, value.amount);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public Receipt decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.orderNumber(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 2:
+                        builder.amount(ProtoAdapter.INT32.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public Receipt redact(Receipt value) {
+            Builder builder = value.newBuilder();
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/proto/receipt.proto b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/proto/receipt.proto
new file mode 100644
index 0000000..a183ff3
--- /dev/null
+++ b/app/src/main/java/br/eng/rodrigoamaro/architectureplayground/coffee/proto/receipt.proto
@@ -0,0 +1,10 @@
+syntax = "proto3";
+
+package br.eng.rodrigoamaro.architectureplayground.coffee.proto;
+
+option java_outer_classname = "ReceiptProto";
+
+message Receipt {
+    string orderNumber = 1;
+    int32 amount = 2;
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/google/protobuf/DescriptorProto.java b/app/src/main/java/com/google/protobuf/DescriptorProto.java
new file mode 100644
index 0000000..1054592
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/DescriptorProto.java
@@ -0,0 +1,732 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+/**
+ * Describes a message type.
+ */
+public final class DescriptorProto extends Message<DescriptorProto, DescriptorProto.Builder> {
+    public static final ProtoAdapter<DescriptorProto> ADAPTER = new ProtoAdapter_DescriptorProto();
+    public static final String DEFAULT_NAME = "";
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String name;
+
+    @WireField(
+            tag = 2,
+            adapter = "com.google.protobuf.FieldDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<FieldDescriptorProto> field;
+
+    @WireField(
+            tag = 6,
+            adapter = "com.google.protobuf.FieldDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<FieldDescriptorProto> extension;
+
+    @WireField(
+            tag = 3,
+            adapter = "com.google.protobuf.DescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<DescriptorProto> nested_type;
+
+    @WireField(
+            tag = 4,
+            adapter = "com.google.protobuf.EnumDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<EnumDescriptorProto> enum_type;
+
+    @WireField(
+            tag = 5,
+            adapter = "com.google.protobuf.DescriptorProto$ExtensionRange#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<ExtensionRange> extension_range;
+
+    @WireField(
+            tag = 8,
+            adapter = "com.google.protobuf.OneofDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<OneofDescriptorProto> oneof_decl;
+
+    @WireField(
+            tag = 7,
+            adapter = "com.google.protobuf.MessageOptions#ADAPTER"
+    )
+    public final MessageOptions options;
+
+    @WireField(
+            tag = 9,
+            adapter = "com.google.protobuf.DescriptorProto$ReservedRange#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<ReservedRange> reserved_range;
+
+    /**
+     * Reserved field names, which may not be used by fields in the same message.
+     * A given name may only be reserved once.
+     */
+    @WireField(
+            tag = 10,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING",
+            label = WireField.Label.REPEATED
+    )
+    public final List<String> reserved_name;
+
+    public DescriptorProto(String name, List<FieldDescriptorProto> field,
+                           List<FieldDescriptorProto> extension, List<DescriptorProto> nested_type,
+                           List<EnumDescriptorProto> enum_type, List<ExtensionRange> extension_range,
+                           List<OneofDescriptorProto> oneof_decl, MessageOptions options,
+                           List<ReservedRange> reserved_range, List<String> reserved_name) {
+        this(name, field, extension, nested_type, enum_type, extension_range, oneof_decl, options, reserved_range, reserved_name, ByteString.EMPTY);
+    }
+
+    public DescriptorProto(String name, List<FieldDescriptorProto> field,
+                           List<FieldDescriptorProto> extension, List<DescriptorProto> nested_type,
+                           List<EnumDescriptorProto> enum_type, List<ExtensionRange> extension_range,
+                           List<OneofDescriptorProto> oneof_decl, MessageOptions options,
+                           List<ReservedRange> reserved_range, List<String> reserved_name, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = name;
+        this.field = Internal.immutableCopyOf("field", field);
+        this.extension = Internal.immutableCopyOf("extension", extension);
+        this.nested_type = Internal.immutableCopyOf("nested_type", nested_type);
+        this.enum_type = Internal.immutableCopyOf("enum_type", enum_type);
+        this.extension_range = Internal.immutableCopyOf("extension_range", extension_range);
+        this.oneof_decl = Internal.immutableCopyOf("oneof_decl", oneof_decl);
+        this.options = options;
+        this.reserved_range = Internal.immutableCopyOf("reserved_range", reserved_range);
+        this.reserved_name = Internal.immutableCopyOf("reserved_name", reserved_name);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = name;
+        builder.field = Internal.copyOf("field", field);
+        builder.extension = Internal.copyOf("extension", extension);
+        builder.nested_type = Internal.copyOf("nested_type", nested_type);
+        builder.enum_type = Internal.copyOf("enum_type", enum_type);
+        builder.extension_range = Internal.copyOf("extension_range", extension_range);
+        builder.oneof_decl = Internal.copyOf("oneof_decl", oneof_decl);
+        builder.options = options;
+        builder.reserved_range = Internal.copyOf("reserved_range", reserved_range);
+        builder.reserved_name = Internal.copyOf("reserved_name", reserved_name);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DescriptorProto)) {
+            return false;
+        }
+        DescriptorProto o = (DescriptorProto) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(name, o.name)
+                && field.equals(o.field)
+                && extension.equals(o.extension)
+                && nested_type.equals(o.nested_type)
+                && enum_type.equals(o.enum_type)
+                && extension_range.equals(o.extension_range)
+                && oneof_decl.equals(o.oneof_decl)
+                && Internal.equals(options, o.options)
+                && reserved_range.equals(o.reserved_range)
+                && reserved_name.equals(o.reserved_name);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (name != null ? name.hashCode() : 0);
+            result = result * 37 + field.hashCode();
+            result = result * 37 + extension.hashCode();
+            result = result * 37 + nested_type.hashCode();
+            result = result * 37 + enum_type.hashCode();
+            result = result * 37 + extension_range.hashCode();
+            result = result * 37 + oneof_decl.hashCode();
+            result = result * 37 + (options != null ? options.hashCode() : 0);
+            result = result * 37 + reserved_range.hashCode();
+            result = result * 37 + reserved_name.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (name != null) {
+            builder.append(", name=").append(name);
+        }
+        if (!field.isEmpty()) {
+            builder.append(", field=").append(field);
+        }
+        if (!extension.isEmpty()) {
+            builder.append(", extension=").append(extension);
+        }
+        if (!nested_type.isEmpty()) {
+            builder.append(", nested_type=").append(nested_type);
+        }
+        if (!enum_type.isEmpty()) {
+            builder.append(", enum_type=").append(enum_type);
+        }
+        if (!extension_range.isEmpty()) {
+            builder.append(", extension_range=").append(extension_range);
+        }
+        if (!oneof_decl.isEmpty()) {
+            builder.append(", oneof_decl=").append(oneof_decl);
+        }
+        if (options != null) {
+            builder.append(", options=").append(options);
+        }
+        if (!reserved_range.isEmpty()) {
+            builder.append(", reserved_range=").append(reserved_range);
+        }
+        if (!reserved_name.isEmpty()) {
+            builder.append(", reserved_name=").append(reserved_name);
+        }
+        return builder.replace(0, 2, "DescriptorProto{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<DescriptorProto, Builder> {
+        public String name;
+
+        public List<FieldDescriptorProto> field;
+
+        public List<FieldDescriptorProto> extension;
+
+        public List<DescriptorProto> nested_type;
+
+        public List<EnumDescriptorProto> enum_type;
+
+        public List<ExtensionRange> extension_range;
+
+        public List<OneofDescriptorProto> oneof_decl;
+
+        public MessageOptions options;
+
+        public List<ReservedRange> reserved_range;
+
+        public List<String> reserved_name;
+
+        public Builder() {
+            field = Internal.newMutableList();
+            extension = Internal.newMutableList();
+            nested_type = Internal.newMutableList();
+            enum_type = Internal.newMutableList();
+            extension_range = Internal.newMutableList();
+            oneof_decl = Internal.newMutableList();
+            reserved_range = Internal.newMutableList();
+            reserved_name = Internal.newMutableList();
+        }
+
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        public Builder field(List<FieldDescriptorProto> field) {
+            Internal.checkElementsNotNull(field);
+            this.field = field;
+            return this;
+        }
+
+        public Builder extension(List<FieldDescriptorProto> extension) {
+            Internal.checkElementsNotNull(extension);
+            this.extension = extension;
+            return this;
+        }
+
+        public Builder nested_type(List<DescriptorProto> nested_type) {
+            Internal.checkElementsNotNull(nested_type);
+            this.nested_type = nested_type;
+            return this;
+        }
+
+        public Builder enum_type(List<EnumDescriptorProto> enum_type) {
+            Internal.checkElementsNotNull(enum_type);
+            this.enum_type = enum_type;
+            return this;
+        }
+
+        public Builder extension_range(List<ExtensionRange> extension_range) {
+            Internal.checkElementsNotNull(extension_range);
+            this.extension_range = extension_range;
+            return this;
+        }
+
+        public Builder oneof_decl(List<OneofDescriptorProto> oneof_decl) {
+            Internal.checkElementsNotNull(oneof_decl);
+            this.oneof_decl = oneof_decl;
+            return this;
+        }
+
+        public Builder options(MessageOptions options) {
+            this.options = options;
+            return this;
+        }
+
+        public Builder reserved_range(List<ReservedRange> reserved_range) {
+            Internal.checkElementsNotNull(reserved_range);
+            this.reserved_range = reserved_range;
+            return this;
+        }
+
+        /**
+         * Reserved field names, which may not be used by fields in the same message.
+         * A given name may only be reserved once.
+         */
+        public Builder reserved_name(List<String> reserved_name) {
+            Internal.checkElementsNotNull(reserved_name);
+            this.reserved_name = reserved_name;
+            return this;
+        }
+
+        @Override
+        public DescriptorProto build() {
+            return new DescriptorProto(name, field, extension, nested_type, enum_type, extension_range, oneof_decl, options, reserved_range, reserved_name, super.buildUnknownFields());
+        }
+    }
+
+    public static final class ExtensionRange extends Message<ExtensionRange, ExtensionRange.Builder> {
+        public static final ProtoAdapter<ExtensionRange> ADAPTER = new ProtoAdapter_ExtensionRange();
+        public static final Integer DEFAULT_START = 0;
+        public static final Integer DEFAULT_END = 0;
+        private static final long serialVersionUID = 0L;
+        @WireField(
+                tag = 1,
+                adapter = "com.squareup.wire.ProtoAdapter#INT32"
+        )
+        public final Integer start;
+
+        @WireField(
+                tag = 2,
+                adapter = "com.squareup.wire.ProtoAdapter#INT32"
+        )
+        public final Integer end;
+
+        public ExtensionRange(Integer start, Integer end) {
+            this(start, end, ByteString.EMPTY);
+        }
+
+        public ExtensionRange(Integer start, Integer end, ByteString unknownFields) {
+            super(ADAPTER, unknownFields);
+            this.start = start;
+            this.end = end;
+        }
+
+        @Override
+        public Builder newBuilder() {
+            Builder builder = new Builder();
+            builder.start = start;
+            builder.end = end;
+            builder.addUnknownFields(unknownFields());
+            return builder;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if (other == this) {
+                return true;
+            }
+            if (!(other instanceof ExtensionRange)) {
+                return false;
+            }
+            ExtensionRange o = (ExtensionRange) other;
+            return unknownFields().equals(o.unknownFields())
+                    && Internal.equals(start, o.start)
+                    && Internal.equals(end, o.end);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = super.hashCode;
+            if (result == 0) {
+                result = unknownFields().hashCode();
+                result = result * 37 + (start != null ? start.hashCode() : 0);
+                result = result * 37 + (end != null ? end.hashCode() : 0);
+                super.hashCode = result;
+            }
+            return result;
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder builder = new StringBuilder();
+            if (start != null) {
+                builder.append(", start=").append(start);
+            }
+            if (end != null) {
+                builder.append(", end=").append(end);
+            }
+            return builder.replace(0, 2, "ExtensionRange{").append('}').toString();
+        }
+
+        public static final class Builder extends Message.Builder<ExtensionRange, Builder> {
+            public Integer start;
+
+            public Integer end;
+
+            public Builder() {
+            }
+
+            public Builder start(Integer start) {
+                this.start = start;
+                return this;
+            }
+
+            public Builder end(Integer end) {
+                this.end = end;
+                return this;
+            }
+
+            @Override
+            public ExtensionRange build() {
+                return new ExtensionRange(start, end, super.buildUnknownFields());
+            }
+        }
+
+        private static final class ProtoAdapter_ExtensionRange extends ProtoAdapter<ExtensionRange> {
+            public ProtoAdapter_ExtensionRange() {
+                super(FieldEncoding.LENGTH_DELIMITED, ExtensionRange.class);
+            }
+
+            @Override
+            public int encodedSize(ExtensionRange value) {
+                return ProtoAdapter.INT32.encodedSizeWithTag(1, value.start)
+                        + ProtoAdapter.INT32.encodedSizeWithTag(2, value.end)
+                        + value.unknownFields().size();
+            }
+
+            @Override
+            public void encode(ProtoWriter writer, ExtensionRange value) throws IOException {
+                ProtoAdapter.INT32.encodeWithTag(writer, 1, value.start);
+                ProtoAdapter.INT32.encodeWithTag(writer, 2, value.end);
+                writer.writeBytes(value.unknownFields());
+            }
+
+            @Override
+            public ExtensionRange decode(ProtoReader reader) throws IOException {
+                Builder builder = new Builder();
+                long token = reader.beginMessage();
+                for (int tag; (tag = reader.nextTag()) != -1; ) {
+                    switch (tag) {
+                        case 1:
+                            builder.start(ProtoAdapter.INT32.decode(reader));
+                            break;
+                        case 2:
+                            builder.end(ProtoAdapter.INT32.decode(reader));
+                            break;
+                        default: {
+                            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                            builder.addUnknownField(tag, fieldEncoding, value);
+                        }
+                    }
+                }
+                reader.endMessage(token);
+                return builder.build();
+            }
+
+            @Override
+            public ExtensionRange redact(ExtensionRange value) {
+                Builder builder = value.newBuilder();
+                builder.clearUnknownFields();
+                return builder.build();
+            }
+        }
+    }
+
+    /**
+     * Range of reserved tag numbers. Reserved tag numbers may not be used by
+     * fields or extension ranges in the same message. Reserved ranges may
+     * not overlap.
+     */
+    public static final class ReservedRange extends Message<ReservedRange, ReservedRange.Builder> {
+        public static final ProtoAdapter<ReservedRange> ADAPTER = new ProtoAdapter_ReservedRange();
+        public static final Integer DEFAULT_START = 0;
+        public static final Integer DEFAULT_END = 0;
+        private static final long serialVersionUID = 0L;
+        /**
+         * Inclusive.
+         */
+        @WireField(
+                tag = 1,
+                adapter = "com.squareup.wire.ProtoAdapter#INT32"
+        )
+        public final Integer start;
+
+        /**
+         * Exclusive.
+         */
+        @WireField(
+                tag = 2,
+                adapter = "com.squareup.wire.ProtoAdapter#INT32"
+        )
+        public final Integer end;
+
+        public ReservedRange(Integer start, Integer end) {
+            this(start, end, ByteString.EMPTY);
+        }
+
+        public ReservedRange(Integer start, Integer end, ByteString unknownFields) {
+            super(ADAPTER, unknownFields);
+            this.start = start;
+            this.end = end;
+        }
+
+        @Override
+        public Builder newBuilder() {
+            Builder builder = new Builder();
+            builder.start = start;
+            builder.end = end;
+            builder.addUnknownFields(unknownFields());
+            return builder;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if (other == this) {
+                return true;
+            }
+            if (!(other instanceof ReservedRange)) {
+                return false;
+            }
+            ReservedRange o = (ReservedRange) other;
+            return unknownFields().equals(o.unknownFields())
+                    && Internal.equals(start, o.start)
+                    && Internal.equals(end, o.end);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = super.hashCode;
+            if (result == 0) {
+                result = unknownFields().hashCode();
+                result = result * 37 + (start != null ? start.hashCode() : 0);
+                result = result * 37 + (end != null ? end.hashCode() : 0);
+                super.hashCode = result;
+            }
+            return result;
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder builder = new StringBuilder();
+            if (start != null) {
+                builder.append(", start=").append(start);
+            }
+            if (end != null) {
+                builder.append(", end=").append(end);
+            }
+            return builder.replace(0, 2, "ReservedRange{").append('}').toString();
+        }
+
+        public static final class Builder extends Message.Builder<ReservedRange, Builder> {
+            public Integer start;
+
+            public Integer end;
+
+            public Builder() {
+            }
+
+            /**
+             * Inclusive.
+             */
+            public Builder start(Integer start) {
+                this.start = start;
+                return this;
+            }
+
+            /**
+             * Exclusive.
+             */
+            public Builder end(Integer end) {
+                this.end = end;
+                return this;
+            }
+
+            @Override
+            public ReservedRange build() {
+                return new ReservedRange(start, end, super.buildUnknownFields());
+            }
+        }
+
+        private static final class ProtoAdapter_ReservedRange extends ProtoAdapter<ReservedRange> {
+            public ProtoAdapter_ReservedRange() {
+                super(FieldEncoding.LENGTH_DELIMITED, ReservedRange.class);
+            }
+
+            @Override
+            public int encodedSize(ReservedRange value) {
+                return ProtoAdapter.INT32.encodedSizeWithTag(1, value.start)
+                        + ProtoAdapter.INT32.encodedSizeWithTag(2, value.end)
+                        + value.unknownFields().size();
+            }
+
+            @Override
+            public void encode(ProtoWriter writer, ReservedRange value) throws IOException {
+                ProtoAdapter.INT32.encodeWithTag(writer, 1, value.start);
+                ProtoAdapter.INT32.encodeWithTag(writer, 2, value.end);
+                writer.writeBytes(value.unknownFields());
+            }
+
+            @Override
+            public ReservedRange decode(ProtoReader reader) throws IOException {
+                Builder builder = new Builder();
+                long token = reader.beginMessage();
+                for (int tag; (tag = reader.nextTag()) != -1; ) {
+                    switch (tag) {
+                        case 1:
+                            builder.start(ProtoAdapter.INT32.decode(reader));
+                            break;
+                        case 2:
+                            builder.end(ProtoAdapter.INT32.decode(reader));
+                            break;
+                        default: {
+                            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                            builder.addUnknownField(tag, fieldEncoding, value);
+                        }
+                    }
+                }
+                reader.endMessage(token);
+                return builder.build();
+            }
+
+            @Override
+            public ReservedRange redact(ReservedRange value) {
+                Builder builder = value.newBuilder();
+                builder.clearUnknownFields();
+                return builder.build();
+            }
+        }
+    }
+
+    private static final class ProtoAdapter_DescriptorProto extends ProtoAdapter<DescriptorProto> {
+        public ProtoAdapter_DescriptorProto() {
+            super(FieldEncoding.LENGTH_DELIMITED, DescriptorProto.class);
+        }
+
+        @Override
+        public int encodedSize(DescriptorProto value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)
+                    + FieldDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(2, value.field)
+                    + FieldDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(6, value.extension)
+                    + DescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(3, value.nested_type)
+                    + EnumDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(4, value.enum_type)
+                    + ExtensionRange.ADAPTER.asRepeated().encodedSizeWithTag(5, value.extension_range)
+                    + OneofDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(8, value.oneof_decl)
+                    + MessageOptions.ADAPTER.encodedSizeWithTag(7, value.options)
+                    + ReservedRange.ADAPTER.asRepeated().encodedSizeWithTag(9, value.reserved_range)
+                    + ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(10, value.reserved_name)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, DescriptorProto value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name);
+            FieldDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 2, value.field);
+            FieldDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 6, value.extension);
+            DescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 3, value.nested_type);
+            EnumDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 4, value.enum_type);
+            ExtensionRange.ADAPTER.asRepeated().encodeWithTag(writer, 5, value.extension_range);
+            OneofDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 8, value.oneof_decl);
+            MessageOptions.ADAPTER.encodeWithTag(writer, 7, value.options);
+            ReservedRange.ADAPTER.asRepeated().encodeWithTag(writer, 9, value.reserved_range);
+            ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 10, value.reserved_name);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public DescriptorProto decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 2:
+                        builder.field.add(FieldDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 3:
+                        builder.nested_type.add(DescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 4:
+                        builder.enum_type.add(EnumDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 5:
+                        builder.extension_range.add(ExtensionRange.ADAPTER.decode(reader));
+                        break;
+                    case 6:
+                        builder.extension.add(FieldDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 7:
+                        builder.options(MessageOptions.ADAPTER.decode(reader));
+                        break;
+                    case 8:
+                        builder.oneof_decl.add(OneofDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 9:
+                        builder.reserved_range.add(ReservedRange.ADAPTER.decode(reader));
+                        break;
+                    case 10:
+                        builder.reserved_name.add(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public DescriptorProto redact(DescriptorProto value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.field, FieldDescriptorProto.ADAPTER);
+            Internal.redactElements(builder.extension, FieldDescriptorProto.ADAPTER);
+            Internal.redactElements(builder.nested_type, DescriptorProto.ADAPTER);
+            Internal.redactElements(builder.enum_type, EnumDescriptorProto.ADAPTER);
+            Internal.redactElements(builder.extension_range, ExtensionRange.ADAPTER);
+            Internal.redactElements(builder.oneof_decl, OneofDescriptorProto.ADAPTER);
+            if (builder.options != null) {
+                builder.options = MessageOptions.ADAPTER.redact(builder.options);
+            }
+            Internal.redactElements(builder.reserved_range, ReservedRange.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/EnumDescriptorProto.java b/app/src/main/java/com/google/protobuf/EnumDescriptorProto.java
new file mode 100644
index 0000000..639c9a2
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/EnumDescriptorProto.java
@@ -0,0 +1,201 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+/**
+ * Describes an enum type.
+ */
+public final class EnumDescriptorProto extends Message<EnumDescriptorProto, EnumDescriptorProto.Builder> {
+    public static final ProtoAdapter<EnumDescriptorProto> ADAPTER = new ProtoAdapter_EnumDescriptorProto();
+    public static final String DEFAULT_NAME = "";
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String name;
+
+    @WireField(
+            tag = 2,
+            adapter = "com.google.protobuf.EnumValueDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<EnumValueDescriptorProto> value;
+
+    @WireField(
+            tag = 3,
+            adapter = "com.google.protobuf.EnumOptions#ADAPTER"
+    )
+    public final EnumOptions options;
+
+    public EnumDescriptorProto(String name, List<EnumValueDescriptorProto> value,
+                               EnumOptions options) {
+        this(name, value, options, ByteString.EMPTY);
+    }
+
+    public EnumDescriptorProto(String name, List<EnumValueDescriptorProto> value, EnumOptions options,
+                               ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = name;
+        this.value = Internal.immutableCopyOf("value", value);
+        this.options = options;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = name;
+        builder.value = Internal.copyOf("value", value);
+        builder.options = options;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof EnumDescriptorProto)) {
+            return false;
+        }
+        EnumDescriptorProto o = (EnumDescriptorProto) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(name, o.name)
+                && value.equals(o.value)
+                && Internal.equals(options, o.options);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (name != null ? name.hashCode() : 0);
+            result = result * 37 + value.hashCode();
+            result = result * 37 + (options != null ? options.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (name != null) {
+            builder.append(", name=").append(name);
+        }
+        if (!value.isEmpty()) {
+            builder.append(", value=").append(value);
+        }
+        if (options != null) {
+            builder.append(", options=").append(options);
+        }
+        return builder.replace(0, 2, "EnumDescriptorProto{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<EnumDescriptorProto, Builder> {
+        public String name;
+
+        public List<EnumValueDescriptorProto> value;
+
+        public EnumOptions options;
+
+        public Builder() {
+            value = Internal.newMutableList();
+        }
+
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        public Builder value(List<EnumValueDescriptorProto> value) {
+            Internal.checkElementsNotNull(value);
+            this.value = value;
+            return this;
+        }
+
+        public Builder options(EnumOptions options) {
+            this.options = options;
+            return this;
+        }
+
+        @Override
+        public EnumDescriptorProto build() {
+            return new EnumDescriptorProto(name, value, options, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_EnumDescriptorProto extends ProtoAdapter<EnumDescriptorProto> {
+        public ProtoAdapter_EnumDescriptorProto() {
+            super(FieldEncoding.LENGTH_DELIMITED, EnumDescriptorProto.class);
+        }
+
+        @Override
+        public int encodedSize(EnumDescriptorProto value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)
+                    + EnumValueDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(2, value.value)
+                    + EnumOptions.ADAPTER.encodedSizeWithTag(3, value.options)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, EnumDescriptorProto value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name);
+            EnumValueDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 2, value.value);
+            EnumOptions.ADAPTER.encodeWithTag(writer, 3, value.options);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public EnumDescriptorProto decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 2:
+                        builder.value.add(EnumValueDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 3:
+                        builder.options(EnumOptions.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public EnumDescriptorProto redact(EnumDescriptorProto value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.value, EnumValueDescriptorProto.ADAPTER);
+            if (builder.options != null) {
+                builder.options = EnumOptions.ADAPTER.redact(builder.options);
+            }
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/EnumOptions.java b/app/src/main/java/com/google/protobuf/EnumOptions.java
new file mode 100644
index 0000000..c2092d8
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/EnumOptions.java
@@ -0,0 +1,222 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+public final class EnumOptions extends Message<EnumOptions, EnumOptions.Builder> {
+    public static final ProtoAdapter<EnumOptions> ADAPTER = new ProtoAdapter_EnumOptions();
+    public static final Boolean DEFAULT_ALLOW_ALIAS = false;
+    public static final Boolean DEFAULT_DEPRECATED = false;
+    private static final long serialVersionUID = 0L;
+    /**
+     * Set this option to true to allow mapping different tag names to the same
+     * value.
+     */
+    @WireField(
+            tag = 2,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean allow_alias;
+
+    /**
+     * Is this enum deprecated?
+     * Depending on the target platform, this can emit Deprecated annotations
+     * for the enum, or it will be completely ignored; in the very least, this
+     * is a formalization for deprecating enums.
+     */
+    @WireField(
+            tag = 3,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean deprecated;
+
+    /**
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    @WireField(
+            tag = 999,
+            adapter = "com.google.protobuf.UninterpretedOption#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<UninterpretedOption> uninterpreted_option;
+
+    public EnumOptions(Boolean allow_alias, Boolean deprecated,
+                       List<UninterpretedOption> uninterpreted_option) {
+        this(allow_alias, deprecated, uninterpreted_option, ByteString.EMPTY);
+    }
+
+    public EnumOptions(Boolean allow_alias, Boolean deprecated,
+                       List<UninterpretedOption> uninterpreted_option, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.allow_alias = allow_alias;
+        this.deprecated = deprecated;
+        this.uninterpreted_option = Internal.immutableCopyOf("uninterpreted_option", uninterpreted_option);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.allow_alias = allow_alias;
+        builder.deprecated = deprecated;
+        builder.uninterpreted_option = Internal.copyOf("uninterpreted_option", uninterpreted_option);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof EnumOptions)) {
+            return false;
+        }
+        EnumOptions o = (EnumOptions) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(allow_alias, o.allow_alias)
+                && Internal.equals(deprecated, o.deprecated)
+                && uninterpreted_option.equals(o.uninterpreted_option);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (allow_alias != null ? allow_alias.hashCode() : 0);
+            result = result * 37 + (deprecated != null ? deprecated.hashCode() : 0);
+            result = result * 37 + uninterpreted_option.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (allow_alias != null) {
+            builder.append(", allow_alias=").append(allow_alias);
+        }
+        if (deprecated != null) {
+            builder.append(", deprecated=").append(deprecated);
+        }
+        if (!uninterpreted_option.isEmpty()) {
+            builder.append(", uninterpreted_option=").append(uninterpreted_option);
+        }
+        return builder.replace(0, 2, "EnumOptions{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<EnumOptions, Builder> {
+        public Boolean allow_alias;
+
+        public Boolean deprecated;
+
+        public List<UninterpretedOption> uninterpreted_option;
+
+        public Builder() {
+            uninterpreted_option = Internal.newMutableList();
+        }
+
+        /**
+         * Set this option to true to allow mapping different tag names to the same
+         * value.
+         */
+        public Builder allow_alias(Boolean allow_alias) {
+            this.allow_alias = allow_alias;
+            return this;
+        }
+
+        /**
+         * Is this enum deprecated?
+         * Depending on the target platform, this can emit Deprecated annotations
+         * for the enum, or it will be completely ignored; in the very least, this
+         * is a formalization for deprecating enums.
+         */
+        public Builder deprecated(Boolean deprecated) {
+            this.deprecated = deprecated;
+            return this;
+        }
+
+        /**
+         * The parser stores options it doesn't recognize here. See above.
+         */
+        public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+            Internal.checkElementsNotNull(uninterpreted_option);
+            this.uninterpreted_option = uninterpreted_option;
+            return this;
+        }
+
+        @Override
+        public EnumOptions build() {
+            return new EnumOptions(allow_alias, deprecated, uninterpreted_option, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_EnumOptions extends ProtoAdapter<EnumOptions> {
+        public ProtoAdapter_EnumOptions() {
+            super(FieldEncoding.LENGTH_DELIMITED, EnumOptions.class);
+        }
+
+        @Override
+        public int encodedSize(EnumOptions value) {
+            return ProtoAdapter.BOOL.encodedSizeWithTag(2, value.allow_alias)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(3, value.deprecated)
+                    + UninterpretedOption.ADAPTER.asRepeated().encodedSizeWithTag(999, value.uninterpreted_option)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, EnumOptions value) throws IOException {
+            ProtoAdapter.BOOL.encodeWithTag(writer, 2, value.allow_alias);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 3, value.deprecated);
+            UninterpretedOption.ADAPTER.asRepeated().encodeWithTag(writer, 999, value.uninterpreted_option);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public EnumOptions decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 2:
+                        builder.allow_alias(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 3:
+                        builder.deprecated(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 999:
+                        builder.uninterpreted_option.add(UninterpretedOption.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public EnumOptions redact(EnumOptions value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.uninterpreted_option, UninterpretedOption.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/EnumValueDescriptorProto.java b/app/src/main/java/com/google/protobuf/EnumValueDescriptorProto.java
new file mode 100644
index 0000000..60a213d
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/EnumValueDescriptorProto.java
@@ -0,0 +1,196 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+
+import okio.ByteString;
+
+/**
+ * Describes a value within an enum.
+ */
+public final class EnumValueDescriptorProto extends Message<EnumValueDescriptorProto, EnumValueDescriptorProto.Builder> {
+    public static final ProtoAdapter<EnumValueDescriptorProto> ADAPTER = new ProtoAdapter_EnumValueDescriptorProto();
+    public static final String DEFAULT_NAME = "";
+    public static final Integer DEFAULT_NUMBER = 0;
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String name;
+
+    @WireField(
+            tag = 2,
+            adapter = "com.squareup.wire.ProtoAdapter#INT32"
+    )
+    public final Integer number;
+
+    @WireField(
+            tag = 3,
+            adapter = "com.google.protobuf.EnumValueOptions#ADAPTER"
+    )
+    public final EnumValueOptions options;
+
+    public EnumValueDescriptorProto(String name, Integer number, EnumValueOptions options) {
+        this(name, number, options, ByteString.EMPTY);
+    }
+
+    public EnumValueDescriptorProto(String name, Integer number, EnumValueOptions options,
+                                    ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = name;
+        this.number = number;
+        this.options = options;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = name;
+        builder.number = number;
+        builder.options = options;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof EnumValueDescriptorProto)) {
+            return false;
+        }
+        EnumValueDescriptorProto o = (EnumValueDescriptorProto) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(name, o.name)
+                && Internal.equals(number, o.number)
+                && Internal.equals(options, o.options);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (name != null ? name.hashCode() : 0);
+            result = result * 37 + (number != null ? number.hashCode() : 0);
+            result = result * 37 + (options != null ? options.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (name != null) {
+            builder.append(", name=").append(name);
+        }
+        if (number != null) {
+            builder.append(", number=").append(number);
+        }
+        if (options != null) {
+            builder.append(", options=").append(options);
+        }
+        return builder.replace(0, 2, "EnumValueDescriptorProto{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<EnumValueDescriptorProto, Builder> {
+        public String name;
+
+        public Integer number;
+
+        public EnumValueOptions options;
+
+        public Builder() {
+        }
+
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        public Builder number(Integer number) {
+            this.number = number;
+            return this;
+        }
+
+        public Builder options(EnumValueOptions options) {
+            this.options = options;
+            return this;
+        }
+
+        @Override
+        public EnumValueDescriptorProto build() {
+            return new EnumValueDescriptorProto(name, number, options, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_EnumValueDescriptorProto extends ProtoAdapter<EnumValueDescriptorProto> {
+        public ProtoAdapter_EnumValueDescriptorProto() {
+            super(FieldEncoding.LENGTH_DELIMITED, EnumValueDescriptorProto.class);
+        }
+
+        @Override
+        public int encodedSize(EnumValueDescriptorProto value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)
+                    + ProtoAdapter.INT32.encodedSizeWithTag(2, value.number)
+                    + EnumValueOptions.ADAPTER.encodedSizeWithTag(3, value.options)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, EnumValueDescriptorProto value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name);
+            ProtoAdapter.INT32.encodeWithTag(writer, 2, value.number);
+            EnumValueOptions.ADAPTER.encodeWithTag(writer, 3, value.options);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public EnumValueDescriptorProto decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 2:
+                        builder.number(ProtoAdapter.INT32.decode(reader));
+                        break;
+                    case 3:
+                        builder.options(EnumValueOptions.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public EnumValueDescriptorProto redact(EnumValueDescriptorProto value) {
+            Builder builder = value.newBuilder();
+            if (builder.options != null) {
+                builder.options = EnumValueOptions.ADAPTER.redact(builder.options);
+            }
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/EnumValueOptions.java b/app/src/main/java/com/google/protobuf/EnumValueOptions.java
new file mode 100644
index 0000000..c8c969d
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/EnumValueOptions.java
@@ -0,0 +1,187 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+public final class EnumValueOptions extends Message<EnumValueOptions, EnumValueOptions.Builder> {
+    public static final ProtoAdapter<EnumValueOptions> ADAPTER = new ProtoAdapter_EnumValueOptions();
+    public static final Boolean DEFAULT_DEPRECATED = false;
+    private static final long serialVersionUID = 0L;
+    /**
+     * Is this enum value deprecated?
+     * Depending on the target platform, this can emit Deprecated annotations
+     * for the enum value, or it will be completely ignored; in the very least,
+     * this is a formalization for deprecating enum values.
+     */
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean deprecated;
+
+    /**
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    @WireField(
+            tag = 999,
+            adapter = "com.google.protobuf.UninterpretedOption#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<UninterpretedOption> uninterpreted_option;
+
+    public EnumValueOptions(Boolean deprecated, List<UninterpretedOption> uninterpreted_option) {
+        this(deprecated, uninterpreted_option, ByteString.EMPTY);
+    }
+
+    public EnumValueOptions(Boolean deprecated, List<UninterpretedOption> uninterpreted_option,
+                            ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.deprecated = deprecated;
+        this.uninterpreted_option = Internal.immutableCopyOf("uninterpreted_option", uninterpreted_option);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.deprecated = deprecated;
+        builder.uninterpreted_option = Internal.copyOf("uninterpreted_option", uninterpreted_option);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof EnumValueOptions)) {
+            return false;
+        }
+        EnumValueOptions o = (EnumValueOptions) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(deprecated, o.deprecated)
+                && uninterpreted_option.equals(o.uninterpreted_option);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (deprecated != null ? deprecated.hashCode() : 0);
+            result = result * 37 + uninterpreted_option.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (deprecated != null) {
+            builder.append(", deprecated=").append(deprecated);
+        }
+        if (!uninterpreted_option.isEmpty()) {
+            builder.append(", uninterpreted_option=").append(uninterpreted_option);
+        }
+        return builder.replace(0, 2, "EnumValueOptions{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<EnumValueOptions, Builder> {
+        public Boolean deprecated;
+
+        public List<UninterpretedOption> uninterpreted_option;
+
+        public Builder() {
+            uninterpreted_option = Internal.newMutableList();
+        }
+
+        /**
+         * Is this enum value deprecated?
+         * Depending on the target platform, this can emit Deprecated annotations
+         * for the enum value, or it will be completely ignored; in the very least,
+         * this is a formalization for deprecating enum values.
+         */
+        public Builder deprecated(Boolean deprecated) {
+            this.deprecated = deprecated;
+            return this;
+        }
+
+        /**
+         * The parser stores options it doesn't recognize here. See above.
+         */
+        public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+            Internal.checkElementsNotNull(uninterpreted_option);
+            this.uninterpreted_option = uninterpreted_option;
+            return this;
+        }
+
+        @Override
+        public EnumValueOptions build() {
+            return new EnumValueOptions(deprecated, uninterpreted_option, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_EnumValueOptions extends ProtoAdapter<EnumValueOptions> {
+        public ProtoAdapter_EnumValueOptions() {
+            super(FieldEncoding.LENGTH_DELIMITED, EnumValueOptions.class);
+        }
+
+        @Override
+        public int encodedSize(EnumValueOptions value) {
+            return ProtoAdapter.BOOL.encodedSizeWithTag(1, value.deprecated)
+                    + UninterpretedOption.ADAPTER.asRepeated().encodedSizeWithTag(999, value.uninterpreted_option)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, EnumValueOptions value) throws IOException {
+            ProtoAdapter.BOOL.encodeWithTag(writer, 1, value.deprecated);
+            UninterpretedOption.ADAPTER.asRepeated().encodeWithTag(writer, 999, value.uninterpreted_option);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public EnumValueOptions decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.deprecated(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 999:
+                        builder.uninterpreted_option.add(UninterpretedOption.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public EnumValueOptions redact(EnumValueOptions value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.uninterpreted_option, UninterpretedOption.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/FieldDescriptorProto.java b/app/src/main/java/com/google/protobuf/FieldDescriptorProto.java
new file mode 100644
index 0000000..9cd2de7
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/FieldDescriptorProto.java
@@ -0,0 +1,604 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.EnumAdapter;
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireEnum;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+
+import okio.ByteString;
+
+/**
+ * Describes a field within a message.
+ */
+public final class FieldDescriptorProto extends Message<FieldDescriptorProto, FieldDescriptorProto.Builder> {
+    public static final ProtoAdapter<FieldDescriptorProto> ADAPTER = new ProtoAdapter_FieldDescriptorProto();
+    public static final String DEFAULT_NAME = "";
+    public static final Integer DEFAULT_NUMBER = 0;
+    public static final Label DEFAULT_LABEL = Label.LABEL_OPTIONAL;
+    public static final Type DEFAULT_TYPE = Type.TYPE_DOUBLE;
+    public static final String DEFAULT_TYPE_NAME = "";
+    public static final String DEFAULT_EXTENDEE = "";
+    public static final String DEFAULT_DEFAULT_VALUE = "";
+    public static final Integer DEFAULT_ONEOF_INDEX = 0;
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String name;
+
+    @WireField(
+            tag = 3,
+            adapter = "com.squareup.wire.ProtoAdapter#INT32"
+    )
+    public final Integer number;
+
+    @WireField(
+            tag = 4,
+            adapter = "com.google.protobuf.FieldDescriptorProto$Label#ADAPTER"
+    )
+    public final Label label;
+
+    /**
+     * If type_name is set, this need not be set.  If both this and type_name
+     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
+     */
+    @WireField(
+            tag = 5,
+            adapter = "com.google.protobuf.FieldDescriptorProto$Type#ADAPTER"
+    )
+    public final Type type;
+
+    /**
+     * For message and enum types, this is the name of the type.  If the name
+     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
+     * rules are used to find the type (i.e. first the nested types within this
+     * message are searched, then within the parent, on up to the root
+     * namespace).
+     */
+    @WireField(
+            tag = 6,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String type_name;
+
+    /**
+     * For extensions, this is the name of the type being extended.  It is
+     * resolved in the same manner as type_name.
+     */
+    @WireField(
+            tag = 2,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String extendee;
+
+    /**
+     * For numeric types, contains the original text representation of the value.
+     * For booleans, "true" or "false".
+     * For strings, contains the default text contents (not escaped in any way).
+     * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
+     * TODO(kenton):  Base-64 encode?
+     */
+    @WireField(
+            tag = 7,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String default_value;
+
+    /**
+     * If set, gives the index of a oneof in the containing type's oneof_decl
+     * list.  This field is a member of that oneof.
+     */
+    @WireField(
+            tag = 9,
+            adapter = "com.squareup.wire.ProtoAdapter#INT32"
+    )
+    public final Integer oneof_index;
+
+    @WireField(
+            tag = 8,
+            adapter = "com.google.protobuf.FieldOptions#ADAPTER"
+    )
+    public final FieldOptions options;
+
+    public FieldDescriptorProto(String name, Integer number, Label label, Type type, String type_name,
+                                String extendee, String default_value, Integer oneof_index, FieldOptions options) {
+        this(name, number, label, type, type_name, extendee, default_value, oneof_index, options, ByteString.EMPTY);
+    }
+
+    public FieldDescriptorProto(String name, Integer number, Label label, Type type, String type_name,
+                                String extendee, String default_value, Integer oneof_index, FieldOptions options,
+                                ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = name;
+        this.number = number;
+        this.label = label;
+        this.type = type;
+        this.type_name = type_name;
+        this.extendee = extendee;
+        this.default_value = default_value;
+        this.oneof_index = oneof_index;
+        this.options = options;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = name;
+        builder.number = number;
+        builder.label = label;
+        builder.type = type;
+        builder.type_name = type_name;
+        builder.extendee = extendee;
+        builder.default_value = default_value;
+        builder.oneof_index = oneof_index;
+        builder.options = options;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof FieldDescriptorProto)) {
+            return false;
+        }
+        FieldDescriptorProto o = (FieldDescriptorProto) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(name, o.name)
+                && Internal.equals(number, o.number)
+                && Internal.equals(label, o.label)
+                && Internal.equals(type, o.type)
+                && Internal.equals(type_name, o.type_name)
+                && Internal.equals(extendee, o.extendee)
+                && Internal.equals(default_value, o.default_value)
+                && Internal.equals(oneof_index, o.oneof_index)
+                && Internal.equals(options, o.options);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (name != null ? name.hashCode() : 0);
+            result = result * 37 + (number != null ? number.hashCode() : 0);
+            result = result * 37 + (label != null ? label.hashCode() : 0);
+            result = result * 37 + (type != null ? type.hashCode() : 0);
+            result = result * 37 + (type_name != null ? type_name.hashCode() : 0);
+            result = result * 37 + (extendee != null ? extendee.hashCode() : 0);
+            result = result * 37 + (default_value != null ? default_value.hashCode() : 0);
+            result = result * 37 + (oneof_index != null ? oneof_index.hashCode() : 0);
+            result = result * 37 + (options != null ? options.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (name != null) {
+            builder.append(", name=").append(name);
+        }
+        if (number != null) {
+            builder.append(", number=").append(number);
+        }
+        if (label != null) {
+            builder.append(", label=").append(label);
+        }
+        if (type != null) {
+            builder.append(", type=").append(type);
+        }
+        if (type_name != null) {
+            builder.append(", type_name=").append(type_name);
+        }
+        if (extendee != null) {
+            builder.append(", extendee=").append(extendee);
+        }
+        if (default_value != null) {
+            builder.append(", default_value=").append(default_value);
+        }
+        if (oneof_index != null) {
+            builder.append(", oneof_index=").append(oneof_index);
+        }
+        if (options != null) {
+            builder.append(", options=").append(options);
+        }
+        return builder.replace(0, 2, "FieldDescriptorProto{").append('}').toString();
+    }
+
+    public enum Type implements WireEnum {
+        /**
+         * 0 is reserved for errors.
+         * Order is weird for historical reasons.
+         */
+        TYPE_DOUBLE(1),
+
+        TYPE_FLOAT(2),
+
+        /**
+         * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
+         * negative values are likely.
+         */
+        TYPE_INT64(3),
+
+        TYPE_UINT64(4),
+
+        /**
+         * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
+         * negative values are likely.
+         */
+        TYPE_INT32(5),
+
+        TYPE_FIXED64(6),
+
+        TYPE_FIXED32(7),
+
+        TYPE_BOOL(8),
+
+        TYPE_STRING(9),
+
+        /**
+         * Tag-delimited aggregate.
+         */
+        TYPE_GROUP(10),
+
+        /**
+         * Length-delimited aggregate.
+         */
+        TYPE_MESSAGE(11),
+
+        /**
+         * New in version 2.
+         */
+        TYPE_BYTES(12),
+
+        TYPE_UINT32(13),
+
+        TYPE_ENUM(14),
+
+        TYPE_SFIXED32(15),
+
+        TYPE_SFIXED64(16),
+
+        /**
+         * Uses ZigZag encoding.
+         */
+        TYPE_SINT32(17),
+
+        /**
+         * Uses ZigZag encoding.
+         */
+        TYPE_SINT64(18);
+
+        public static final ProtoAdapter<Type> ADAPTER = new ProtoAdapter_Type();
+
+        private final int value;
+
+        Type(int value) {
+            this.value = value;
+        }
+
+        /**
+         * Return the constant for {@code value} or null.
+         */
+        public static Type fromValue(int value) {
+            switch (value) {
+                case 1:
+                    return TYPE_DOUBLE;
+                case 2:
+                    return TYPE_FLOAT;
+                case 3:
+                    return TYPE_INT64;
+                case 4:
+                    return TYPE_UINT64;
+                case 5:
+                    return TYPE_INT32;
+                case 6:
+                    return TYPE_FIXED64;
+                case 7:
+                    return TYPE_FIXED32;
+                case 8:
+                    return TYPE_BOOL;
+                case 9:
+                    return TYPE_STRING;
+                case 10:
+                    return TYPE_GROUP;
+                case 11:
+                    return TYPE_MESSAGE;
+                case 12:
+                    return TYPE_BYTES;
+                case 13:
+                    return TYPE_UINT32;
+                case 14:
+                    return TYPE_ENUM;
+                case 15:
+                    return TYPE_SFIXED32;
+                case 16:
+                    return TYPE_SFIXED64;
+                case 17:
+                    return TYPE_SINT32;
+                case 18:
+                    return TYPE_SINT64;
+                default:
+                    return null;
+            }
+        }
+
+        @Override
+        public int getValue() {
+            return value;
+        }
+
+        private static final class ProtoAdapter_Type extends EnumAdapter<Type> {
+            ProtoAdapter_Type() {
+                super(Type.class);
+            }
+
+            @Override
+            protected Type fromValue(int value) {
+                return Type.fromValue(value);
+            }
+        }
+    }
+
+    public enum Label implements WireEnum {
+        /**
+         * 0 is reserved for errors
+         */
+        LABEL_OPTIONAL(1),
+
+        LABEL_REQUIRED(2),
+
+        LABEL_REPEATED(3);
+
+        public static final ProtoAdapter<Label> ADAPTER = new ProtoAdapter_Label();
+
+        private final int value;
+
+        Label(int value) {
+            this.value = value;
+        }
+
+        /**
+         * Return the constant for {@code value} or null.
+         */
+        public static Label fromValue(int value) {
+            switch (value) {
+                case 1:
+                    return LABEL_OPTIONAL;
+                case 2:
+                    return LABEL_REQUIRED;
+                case 3:
+                    return LABEL_REPEATED;
+                default:
+                    return null;
+            }
+        }
+
+        @Override
+        public int getValue() {
+            return value;
+        }
+
+        private static final class ProtoAdapter_Label extends EnumAdapter<Label> {
+            ProtoAdapter_Label() {
+                super(Label.class);
+            }
+
+            @Override
+            protected Label fromValue(int value) {
+                return Label.fromValue(value);
+            }
+        }
+    }
+
+    public static final class Builder extends Message.Builder<FieldDescriptorProto, Builder> {
+        public String name;
+
+        public Integer number;
+
+        public Label label;
+
+        public Type type;
+
+        public String type_name;
+
+        public String extendee;
+
+        public String default_value;
+
+        public Integer oneof_index;
+
+        public FieldOptions options;
+
+        public Builder() {
+        }
+
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        public Builder number(Integer number) {
+            this.number = number;
+            return this;
+        }
+
+        public Builder label(Label label) {
+            this.label = label;
+            return this;
+        }
+
+        /**
+         * If type_name is set, this need not be set.  If both this and type_name
+         * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
+         */
+        public Builder type(Type type) {
+            this.type = type;
+            return this;
+        }
+
+        /**
+         * For message and enum types, this is the name of the type.  If the name
+         * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
+         * rules are used to find the type (i.e. first the nested types within this
+         * message are searched, then within the parent, on up to the root
+         * namespace).
+         */
+        public Builder type_name(String type_name) {
+            this.type_name = type_name;
+            return this;
+        }
+
+        /**
+         * For extensions, this is the name of the type being extended.  It is
+         * resolved in the same manner as type_name.
+         */
+        public Builder extendee(String extendee) {
+            this.extendee = extendee;
+            return this;
+        }
+
+        /**
+         * For numeric types, contains the original text representation of the value.
+         * For booleans, "true" or "false".
+         * For strings, contains the default text contents (not escaped in any way).
+         * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
+         * TODO(kenton):  Base-64 encode?
+         */
+        public Builder default_value(String default_value) {
+            this.default_value = default_value;
+            return this;
+        }
+
+        /**
+         * If set, gives the index of a oneof in the containing type's oneof_decl
+         * list.  This field is a member of that oneof.
+         */
+        public Builder oneof_index(Integer oneof_index) {
+            this.oneof_index = oneof_index;
+            return this;
+        }
+
+        public Builder options(FieldOptions options) {
+            this.options = options;
+            return this;
+        }
+
+        @Override
+        public FieldDescriptorProto build() {
+            return new FieldDescriptorProto(name, number, label, type, type_name, extendee, default_value, oneof_index, options, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_FieldDescriptorProto extends ProtoAdapter<FieldDescriptorProto> {
+        public ProtoAdapter_FieldDescriptorProto() {
+            super(FieldEncoding.LENGTH_DELIMITED, FieldDescriptorProto.class);
+        }
+
+        @Override
+        public int encodedSize(FieldDescriptorProto value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)
+                    + ProtoAdapter.INT32.encodedSizeWithTag(3, value.number)
+                    + Label.ADAPTER.encodedSizeWithTag(4, value.label)
+                    + Type.ADAPTER.encodedSizeWithTag(5, value.type)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(6, value.type_name)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(2, value.extendee)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(7, value.default_value)
+                    + ProtoAdapter.INT32.encodedSizeWithTag(9, value.oneof_index)
+                    + FieldOptions.ADAPTER.encodedSizeWithTag(8, value.options)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, FieldDescriptorProto value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name);
+            ProtoAdapter.INT32.encodeWithTag(writer, 3, value.number);
+            Label.ADAPTER.encodeWithTag(writer, 4, value.label);
+            Type.ADAPTER.encodeWithTag(writer, 5, value.type);
+            ProtoAdapter.STRING.encodeWithTag(writer, 6, value.type_name);
+            ProtoAdapter.STRING.encodeWithTag(writer, 2, value.extendee);
+            ProtoAdapter.STRING.encodeWithTag(writer, 7, value.default_value);
+            ProtoAdapter.INT32.encodeWithTag(writer, 9, value.oneof_index);
+            FieldOptions.ADAPTER.encodeWithTag(writer, 8, value.options);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public FieldDescriptorProto decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 2:
+                        builder.extendee(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 3:
+                        builder.number(ProtoAdapter.INT32.decode(reader));
+                        break;
+                    case 4: {
+                        try {
+                            builder.label(Label.ADAPTER.decode(reader));
+                        } catch (ProtoAdapter.EnumConstantNotFoundException e) {
+                            builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
+                        }
+                        break;
+                    }
+                    case 5: {
+                        try {
+                            builder.type(Type.ADAPTER.decode(reader));
+                        } catch (ProtoAdapter.EnumConstantNotFoundException e) {
+                            builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
+                        }
+                        break;
+                    }
+                    case 6:
+                        builder.type_name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 7:
+                        builder.default_value(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 8:
+                        builder.options(FieldOptions.ADAPTER.decode(reader));
+                        break;
+                    case 9:
+                        builder.oneof_index(ProtoAdapter.INT32.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public FieldDescriptorProto redact(FieldDescriptorProto value) {
+            Builder builder = value.newBuilder();
+            if (builder.options != null) {
+                builder.options = FieldOptions.ADAPTER.redact(builder.options);
+            }
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/FieldOptions.java b/app/src/main/java/com/google/protobuf/FieldOptions.java
new file mode 100644
index 0000000..acbdf3d
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/FieldOptions.java
@@ -0,0 +1,552 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.EnumAdapter;
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireEnum;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+public final class FieldOptions extends Message<FieldOptions, FieldOptions.Builder> {
+    public static final ProtoAdapter<FieldOptions> ADAPTER = new ProtoAdapter_FieldOptions();
+    public static final CType DEFAULT_CTYPE = CType.STRING;
+    public static final Boolean DEFAULT_PACKED = false;
+    public static final JSType DEFAULT_JSTYPE = JSType.JS_NORMAL;
+    public static final Boolean DEFAULT_LAZY = false;
+    public static final Boolean DEFAULT_DEPRECATED = false;
+    public static final Boolean DEFAULT_WEAK = false;
+    private static final long serialVersionUID = 0L;
+    /**
+     * The ctype option instructs the C++ code generator to use a different
+     * representation of the field than it normally would.  See the specific
+     * options below.  This option is not yet implemented in the open source
+     * release -- sorry, we'll try to include it in a future version!
+     */
+    @WireField(
+            tag = 1,
+            adapter = "com.google.protobuf.FieldOptions$CType#ADAPTER"
+    )
+    public final CType ctype;
+
+    /**
+     * The packed option can be enabled for repeated primitive fields to enable
+     * a more efficient representation on the wire. Rather than repeatedly
+     * writing the tag and type for each element, the entire array is encoded as
+     * a single length-delimited blob. In proto3, only explicit setting it to
+     * false will avoid using packed encoding.
+     */
+    @WireField(
+            tag = 2,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean packed;
+
+    /**
+     * The jstype option determines the JavaScript type used for values of the
+     * field.  The option is permitted only for 64 bit integral and fixed types
+     * (int64, uint64, sint64, fixed64, sfixed64).  By default these types are
+     * represented as JavaScript strings.  This avoids loss of precision that can
+     * happen when a large value is converted to a floating point JavaScript
+     * numbers.  Specifying JS_NUMBER for the jstype causes the generated
+     * JavaScript code to use the JavaScript "number" type instead of strings.
+     * This option is an enum to permit additional types to be added,
+     * e.g. goog.math.Integer.
+     */
+    @WireField(
+            tag = 6,
+            adapter = "com.google.protobuf.FieldOptions$JSType#ADAPTER"
+    )
+    public final JSType jstype;
+
+    /**
+     * Should this field be parsed lazily?  Lazy applies only to message-type
+     * fields.  It means that when the outer message is initially parsed, the
+     * inner message's contents will not be parsed but instead stored in encoded
+     * form.  The inner message will actually be parsed when it is first accessed.
+     * <p>
+     * This is only a hint.  Implementations are free to choose whether to use
+     * eager or lazy parsing regardless of the value of this option.  However,
+     * setting this option true suggests that the protocol author believes that
+     * using lazy parsing on this field is worth the additional bookkeeping
+     * overhead typically needed to implement it.
+     * <p>
+     * This option does not affect the public interface of any generated code;
+     * all method signatures remain the same.  Furthermore, thread-safety of the
+     * interface is not affected by this option; const methods remain safe to
+     * call from multiple threads concurrently, while non-const methods continue
+     * to require exclusive access.
+     * <p>
+     * <p>
+     * Note that implementations may choose not to check required fields within
+     * a lazy sub-message.  That is, calling IsInitialized() on the outher message
+     * may return true even if the inner message has missing required fields.
+     * This is necessary because otherwise the inner message would have to be
+     * parsed in order to perform the check, defeating the purpose of lazy
+     * parsing.  An implementation which chooses not to check required fields
+     * must be consistent about it.  That is, for any particular sub-message, the
+     * implementation must either *always* check its required fields, or *never*
+     * check its required fields, regardless of whether or not the message has
+     * been parsed.
+     */
+    @WireField(
+            tag = 5,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean lazy;
+
+    /**
+     * Is this field deprecated?
+     * Depending on the target platform, this can emit Deprecated annotations
+     * for accessors, or it will be completely ignored; in the very least, this
+     * is a formalization for deprecating fields.
+     */
+    @WireField(
+            tag = 3,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean deprecated;
+
+    /**
+     * For Google-internal migration only. Do not use.
+     */
+    @WireField(
+            tag = 10,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean weak;
+
+    /**
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    @WireField(
+            tag = 999,
+            adapter = "com.google.protobuf.UninterpretedOption#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<UninterpretedOption> uninterpreted_option;
+
+    public FieldOptions(CType ctype, Boolean packed, JSType jstype, Boolean lazy, Boolean deprecated,
+                        Boolean weak, List<UninterpretedOption> uninterpreted_option) {
+        this(ctype, packed, jstype, lazy, deprecated, weak, uninterpreted_option, ByteString.EMPTY);
+    }
+
+    public FieldOptions(CType ctype, Boolean packed, JSType jstype, Boolean lazy, Boolean deprecated,
+                        Boolean weak, List<UninterpretedOption> uninterpreted_option, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.ctype = ctype;
+        this.packed = packed;
+        this.jstype = jstype;
+        this.lazy = lazy;
+        this.deprecated = deprecated;
+        this.weak = weak;
+        this.uninterpreted_option = Internal.immutableCopyOf("uninterpreted_option", uninterpreted_option);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.ctype = ctype;
+        builder.packed = packed;
+        builder.jstype = jstype;
+        builder.lazy = lazy;
+        builder.deprecated = deprecated;
+        builder.weak = weak;
+        builder.uninterpreted_option = Internal.copyOf("uninterpreted_option", uninterpreted_option);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof FieldOptions)) {
+            return false;
+        }
+        FieldOptions o = (FieldOptions) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(ctype, o.ctype)
+                && Internal.equals(packed, o.packed)
+                && Internal.equals(jstype, o.jstype)
+                && Internal.equals(lazy, o.lazy)
+                && Internal.equals(deprecated, o.deprecated)
+                && Internal.equals(weak, o.weak)
+                && uninterpreted_option.equals(o.uninterpreted_option);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (ctype != null ? ctype.hashCode() : 0);
+            result = result * 37 + (packed != null ? packed.hashCode() : 0);
+            result = result * 37 + (jstype != null ? jstype.hashCode() : 0);
+            result = result * 37 + (lazy != null ? lazy.hashCode() : 0);
+            result = result * 37 + (deprecated != null ? deprecated.hashCode() : 0);
+            result = result * 37 + (weak != null ? weak.hashCode() : 0);
+            result = result * 37 + uninterpreted_option.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (ctype != null) {
+            builder.append(", ctype=").append(ctype);
+        }
+        if (packed != null) {
+            builder.append(", packed=").append(packed);
+        }
+        if (jstype != null) {
+            builder.append(", jstype=").append(jstype);
+        }
+        if (lazy != null) {
+            builder.append(", lazy=").append(lazy);
+        }
+        if (deprecated != null) {
+            builder.append(", deprecated=").append(deprecated);
+        }
+        if (weak != null) {
+            builder.append(", weak=").append(weak);
+        }
+        if (!uninterpreted_option.isEmpty()) {
+            builder.append(", uninterpreted_option=").append(uninterpreted_option);
+        }
+        return builder.replace(0, 2, "FieldOptions{").append('}').toString();
+    }
+
+    public enum CType implements WireEnum {
+        /**
+         * Default mode.
+         */
+        STRING(0),
+
+        CORD(1),
+
+        STRING_PIECE(2);
+
+        public static final ProtoAdapter<CType> ADAPTER = new ProtoAdapter_CType();
+
+        private final int value;
+
+        CType(int value) {
+            this.value = value;
+        }
+
+        /**
+         * Return the constant for {@code value} or null.
+         */
+        public static CType fromValue(int value) {
+            switch (value) {
+                case 0:
+                    return STRING;
+                case 1:
+                    return CORD;
+                case 2:
+                    return STRING_PIECE;
+                default:
+                    return null;
+            }
+        }
+
+        @Override
+        public int getValue() {
+            return value;
+        }
+
+        private static final class ProtoAdapter_CType extends EnumAdapter<CType> {
+            ProtoAdapter_CType() {
+                super(CType.class);
+            }
+
+            @Override
+            protected CType fromValue(int value) {
+                return CType.fromValue(value);
+            }
+        }
+    }
+
+    public enum JSType implements WireEnum {
+        /**
+         * Use the default type.
+         */
+        JS_NORMAL(0),
+
+        /**
+         * Use JavaScript strings.
+         */
+        JS_STRING(1),
+
+        /**
+         * Use JavaScript numbers.
+         */
+        JS_NUMBER(2);
+
+        public static final ProtoAdapter<JSType> ADAPTER = new ProtoAdapter_JSType();
+
+        private final int value;
+
+        JSType(int value) {
+            this.value = value;
+        }
+
+        /**
+         * Return the constant for {@code value} or null.
+         */
+        public static JSType fromValue(int value) {
+            switch (value) {
+                case 0:
+                    return JS_NORMAL;
+                case 1:
+                    return JS_STRING;
+                case 2:
+                    return JS_NUMBER;
+                default:
+                    return null;
+            }
+        }
+
+        @Override
+        public int getValue() {
+            return value;
+        }
+
+        private static final class ProtoAdapter_JSType extends EnumAdapter<JSType> {
+            ProtoAdapter_JSType() {
+                super(JSType.class);
+            }
+
+            @Override
+            protected JSType fromValue(int value) {
+                return JSType.fromValue(value);
+            }
+        }
+    }
+
+    public static final class Builder extends Message.Builder<FieldOptions, Builder> {
+        public CType ctype;
+
+        public Boolean packed;
+
+        public JSType jstype;
+
+        public Boolean lazy;
+
+        public Boolean deprecated;
+
+        public Boolean weak;
+
+        public List<UninterpretedOption> uninterpreted_option;
+
+        public Builder() {
+            uninterpreted_option = Internal.newMutableList();
+        }
+
+        /**
+         * The ctype option instructs the C++ code generator to use a different
+         * representation of the field than it normally would.  See the specific
+         * options below.  This option is not yet implemented in the open source
+         * release -- sorry, we'll try to include it in a future version!
+         */
+        public Builder ctype(CType ctype) {
+            this.ctype = ctype;
+            return this;
+        }
+
+        /**
+         * The packed option can be enabled for repeated primitive fields to enable
+         * a more efficient representation on the wire. Rather than repeatedly
+         * writing the tag and type for each element, the entire array is encoded as
+         * a single length-delimited blob. In proto3, only explicit setting it to
+         * false will avoid using packed encoding.
+         */
+        public Builder packed(Boolean packed) {
+            this.packed = packed;
+            return this;
+        }
+
+        /**
+         * The jstype option determines the JavaScript type used for values of the
+         * field.  The option is permitted only for 64 bit integral and fixed types
+         * (int64, uint64, sint64, fixed64, sfixed64).  By default these types are
+         * represented as JavaScript strings.  This avoids loss of precision that can
+         * happen when a large value is converted to a floating point JavaScript
+         * numbers.  Specifying JS_NUMBER for the jstype causes the generated
+         * JavaScript code to use the JavaScript "number" type instead of strings.
+         * This option is an enum to permit additional types to be added,
+         * e.g. goog.math.Integer.
+         */
+        public Builder jstype(JSType jstype) {
+            this.jstype = jstype;
+            return this;
+        }
+
+        /**
+         * Should this field be parsed lazily?  Lazy applies only to message-type
+         * fields.  It means that when the outer message is initially parsed, the
+         * inner message's contents will not be parsed but instead stored in encoded
+         * form.  The inner message will actually be parsed when it is first accessed.
+         * <p>
+         * This is only a hint.  Implementations are free to choose whether to use
+         * eager or lazy parsing regardless of the value of this option.  However,
+         * setting this option true suggests that the protocol author believes that
+         * using lazy parsing on this field is worth the additional bookkeeping
+         * overhead typically needed to implement it.
+         * <p>
+         * This option does not affect the public interface of any generated code;
+         * all method signatures remain the same.  Furthermore, thread-safety of the
+         * interface is not affected by this option; const methods remain safe to
+         * call from multiple threads concurrently, while non-const methods continue
+         * to require exclusive access.
+         * <p>
+         * <p>
+         * Note that implementations may choose not to check required fields within
+         * a lazy sub-message.  That is, calling IsInitialized() on the outher message
+         * may return true even if the inner message has missing required fields.
+         * This is necessary because otherwise the inner message would have to be
+         * parsed in order to perform the check, defeating the purpose of lazy
+         * parsing.  An implementation which chooses not to check required fields
+         * must be consistent about it.  That is, for any particular sub-message, the
+         * implementation must either *always* check its required fields, or *never*
+         * check its required fields, regardless of whether or not the message has
+         * been parsed.
+         */
+        public Builder lazy(Boolean lazy) {
+            this.lazy = lazy;
+            return this;
+        }
+
+        /**
+         * Is this field deprecated?
+         * Depending on the target platform, this can emit Deprecated annotations
+         * for accessors, or it will be completely ignored; in the very least, this
+         * is a formalization for deprecating fields.
+         */
+        public Builder deprecated(Boolean deprecated) {
+            this.deprecated = deprecated;
+            return this;
+        }
+
+        /**
+         * For Google-internal migration only. Do not use.
+         */
+        public Builder weak(Boolean weak) {
+            this.weak = weak;
+            return this;
+        }
+
+        /**
+         * The parser stores options it doesn't recognize here. See above.
+         */
+        public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+            Internal.checkElementsNotNull(uninterpreted_option);
+            this.uninterpreted_option = uninterpreted_option;
+            return this;
+        }
+
+        @Override
+        public FieldOptions build() {
+            return new FieldOptions(ctype, packed, jstype, lazy, deprecated, weak, uninterpreted_option, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_FieldOptions extends ProtoAdapter<FieldOptions> {
+        public ProtoAdapter_FieldOptions() {
+            super(FieldEncoding.LENGTH_DELIMITED, FieldOptions.class);
+        }
+
+        @Override
+        public int encodedSize(FieldOptions value) {
+            return CType.ADAPTER.encodedSizeWithTag(1, value.ctype)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(2, value.packed)
+                    + JSType.ADAPTER.encodedSizeWithTag(6, value.jstype)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(5, value.lazy)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(3, value.deprecated)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(10, value.weak)
+                    + UninterpretedOption.ADAPTER.asRepeated().encodedSizeWithTag(999, value.uninterpreted_option)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, FieldOptions value) throws IOException {
+            CType.ADAPTER.encodeWithTag(writer, 1, value.ctype);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 2, value.packed);
+            JSType.ADAPTER.encodeWithTag(writer, 6, value.jstype);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 5, value.lazy);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 3, value.deprecated);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 10, value.weak);
+            UninterpretedOption.ADAPTER.asRepeated().encodeWithTag(writer, 999, value.uninterpreted_option);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public FieldOptions decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1: {
+                        try {
+                            builder.ctype(CType.ADAPTER.decode(reader));
+                        } catch (ProtoAdapter.EnumConstantNotFoundException e) {
+                            builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
+                        }
+                        break;
+                    }
+                    case 2:
+                        builder.packed(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 3:
+                        builder.deprecated(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 5:
+                        builder.lazy(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 6: {
+                        try {
+                            builder.jstype(JSType.ADAPTER.decode(reader));
+                        } catch (ProtoAdapter.EnumConstantNotFoundException e) {
+                            builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
+                        }
+                        break;
+                    }
+                    case 10:
+                        builder.weak(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 999:
+                        builder.uninterpreted_option.add(UninterpretedOption.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public FieldOptions redact(FieldOptions value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.uninterpreted_option, UninterpretedOption.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/FileDescriptorProto.java b/app/src/main/java/com/google/protobuf/FileDescriptorProto.java
new file mode 100644
index 0000000..e76e693
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/FileDescriptorProto.java
@@ -0,0 +1,517 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+/**
+ * Describes a complete .proto file.
+ */
+public final class FileDescriptorProto extends Message<FileDescriptorProto, FileDescriptorProto.Builder> {
+    public static final ProtoAdapter<FileDescriptorProto> ADAPTER = new ProtoAdapter_FileDescriptorProto();
+    public static final String DEFAULT_NAME = "";
+    public static final String DEFAULT_PACKAGE_ = "";
+    public static final String DEFAULT_SYNTAX = "";
+    private static final long serialVersionUID = 0L;
+    /**
+     * file name, relative to root of source tree
+     */
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String name;
+
+    /**
+     * e.g. "foo", "foo.bar", etc.
+     */
+    @WireField(
+            tag = 2,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String package_;
+
+    /**
+     * Names of files imported by this file.
+     */
+    @WireField(
+            tag = 3,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING",
+            label = WireField.Label.REPEATED
+    )
+    public final List<String> dependency;
+
+    /**
+     * Indexes of the public imported files in the dependency list above.
+     */
+    @WireField(
+            tag = 10,
+            adapter = "com.squareup.wire.ProtoAdapter#INT32",
+            label = WireField.Label.REPEATED
+    )
+    public final List<Integer> public_dependency;
+
+    /**
+     * Indexes of the weak imported files in the dependency list.
+     * For Google-internal migration only. Do not use.
+     */
+    @WireField(
+            tag = 11,
+            adapter = "com.squareup.wire.ProtoAdapter#INT32",
+            label = WireField.Label.REPEATED
+    )
+    public final List<Integer> weak_dependency;
+
+    /**
+     * All top-level definitions in this file.
+     */
+    @WireField(
+            tag = 4,
+            adapter = "com.google.protobuf.DescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<DescriptorProto> message_type;
+
+    @WireField(
+            tag = 5,
+            adapter = "com.google.protobuf.EnumDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<EnumDescriptorProto> enum_type;
+
+    @WireField(
+            tag = 6,
+            adapter = "com.google.protobuf.ServiceDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<ServiceDescriptorProto> service;
+
+    @WireField(
+            tag = 7,
+            adapter = "com.google.protobuf.FieldDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<FieldDescriptorProto> extension;
+
+    @WireField(
+            tag = 8,
+            adapter = "com.google.protobuf.FileOptions#ADAPTER"
+    )
+    public final FileOptions options;
+
+    /**
+     * This field contains optional information about the original source code.
+     * You may safely remove this entire field without harming runtime
+     * functionality of the descriptors -- the information is needed only by
+     * development tools.
+     */
+    @WireField(
+            tag = 9,
+            adapter = "com.google.protobuf.SourceCodeInfo#ADAPTER"
+    )
+    public final SourceCodeInfo source_code_info;
+
+    /**
+     * The syntax of the proto file.
+     * The supported values are "proto2" and "proto3".
+     */
+    @WireField(
+            tag = 12,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String syntax;
+
+    public FileDescriptorProto(String name, String package_, List<String> dependency,
+                               List<Integer> public_dependency, List<Integer> weak_dependency,
+                               List<DescriptorProto> message_type, List<EnumDescriptorProto> enum_type,
+                               List<ServiceDescriptorProto> service, List<FieldDescriptorProto> extension,
+                               FileOptions options, SourceCodeInfo source_code_info, String syntax) {
+        this(name, package_, dependency, public_dependency, weak_dependency, message_type, enum_type, service, extension, options, source_code_info, syntax, ByteString.EMPTY);
+    }
+
+    public FileDescriptorProto(String name, String package_, List<String> dependency,
+                               List<Integer> public_dependency, List<Integer> weak_dependency,
+                               List<DescriptorProto> message_type, List<EnumDescriptorProto> enum_type,
+                               List<ServiceDescriptorProto> service, List<FieldDescriptorProto> extension,
+                               FileOptions options, SourceCodeInfo source_code_info, String syntax,
+                               ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = name;
+        this.package_ = package_;
+        this.dependency = Internal.immutableCopyOf("dependency", dependency);
+        this.public_dependency = Internal.immutableCopyOf("public_dependency", public_dependency);
+        this.weak_dependency = Internal.immutableCopyOf("weak_dependency", weak_dependency);
+        this.message_type = Internal.immutableCopyOf("message_type", message_type);
+        this.enum_type = Internal.immutableCopyOf("enum_type", enum_type);
+        this.service = Internal.immutableCopyOf("service", service);
+        this.extension = Internal.immutableCopyOf("extension", extension);
+        this.options = options;
+        this.source_code_info = source_code_info;
+        this.syntax = syntax;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = name;
+        builder.package_ = package_;
+        builder.dependency = Internal.copyOf("dependency", dependency);
+        builder.public_dependency = Internal.copyOf("public_dependency", public_dependency);
+        builder.weak_dependency = Internal.copyOf("weak_dependency", weak_dependency);
+        builder.message_type = Internal.copyOf("message_type", message_type);
+        builder.enum_type = Internal.copyOf("enum_type", enum_type);
+        builder.service = Internal.copyOf("service", service);
+        builder.extension = Internal.copyOf("extension", extension);
+        builder.options = options;
+        builder.source_code_info = source_code_info;
+        builder.syntax = syntax;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof FileDescriptorProto)) {
+            return false;
+        }
+        FileDescriptorProto o = (FileDescriptorProto) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(name, o.name)
+                && Internal.equals(package_, o.package_)
+                && dependency.equals(o.dependency)
+                && public_dependency.equals(o.public_dependency)
+                && weak_dependency.equals(o.weak_dependency)
+                && message_type.equals(o.message_type)
+                && enum_type.equals(o.enum_type)
+                && service.equals(o.service)
+                && extension.equals(o.extension)
+                && Internal.equals(options, o.options)
+                && Internal.equals(source_code_info, o.source_code_info)
+                && Internal.equals(syntax, o.syntax);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (name != null ? name.hashCode() : 0);
+            result = result * 37 + (package_ != null ? package_.hashCode() : 0);
+            result = result * 37 + dependency.hashCode();
+            result = result * 37 + public_dependency.hashCode();
+            result = result * 37 + weak_dependency.hashCode();
+            result = result * 37 + message_type.hashCode();
+            result = result * 37 + enum_type.hashCode();
+            result = result * 37 + service.hashCode();
+            result = result * 37 + extension.hashCode();
+            result = result * 37 + (options != null ? options.hashCode() : 0);
+            result = result * 37 + (source_code_info != null ? source_code_info.hashCode() : 0);
+            result = result * 37 + (syntax != null ? syntax.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (name != null) {
+            builder.append(", name=").append(name);
+        }
+        if (package_ != null) {
+            builder.append(", package=").append(package_);
+        }
+        if (!dependency.isEmpty()) {
+            builder.append(", dependency=").append(dependency);
+        }
+        if (!public_dependency.isEmpty()) {
+            builder.append(", public_dependency=").append(public_dependency);
+        }
+        if (!weak_dependency.isEmpty()) {
+            builder.append(", weak_dependency=").append(weak_dependency);
+        }
+        if (!message_type.isEmpty()) {
+            builder.append(", message_type=").append(message_type);
+        }
+        if (!enum_type.isEmpty()) {
+            builder.append(", enum_type=").append(enum_type);
+        }
+        if (!service.isEmpty()) {
+            builder.append(", service=").append(service);
+        }
+        if (!extension.isEmpty()) {
+            builder.append(", extension=").append(extension);
+        }
+        if (options != null) {
+            builder.append(", options=").append(options);
+        }
+        if (source_code_info != null) {
+            builder.append(", source_code_info=").append(source_code_info);
+        }
+        if (syntax != null) {
+            builder.append(", syntax=").append(syntax);
+        }
+        return builder.replace(0, 2, "FileDescriptorProto{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<FileDescriptorProto, Builder> {
+        public String name;
+
+        public String package_;
+
+        public List<String> dependency;
+
+        public List<Integer> public_dependency;
+
+        public List<Integer> weak_dependency;
+
+        public List<DescriptorProto> message_type;
+
+        public List<EnumDescriptorProto> enum_type;
+
+        public List<ServiceDescriptorProto> service;
+
+        public List<FieldDescriptorProto> extension;
+
+        public FileOptions options;
+
+        public SourceCodeInfo source_code_info;
+
+        public String syntax;
+
+        public Builder() {
+            dependency = Internal.newMutableList();
+            public_dependency = Internal.newMutableList();
+            weak_dependency = Internal.newMutableList();
+            message_type = Internal.newMutableList();
+            enum_type = Internal.newMutableList();
+            service = Internal.newMutableList();
+            extension = Internal.newMutableList();
+        }
+
+        /**
+         * file name, relative to root of source tree
+         */
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        /**
+         * e.g. "foo", "foo.bar", etc.
+         */
+        public Builder package_(String package_) {
+            this.package_ = package_;
+            return this;
+        }
+
+        /**
+         * Names of files imported by this file.
+         */
+        public Builder dependency(List<String> dependency) {
+            Internal.checkElementsNotNull(dependency);
+            this.dependency = dependency;
+            return this;
+        }
+
+        /**
+         * Indexes of the public imported files in the dependency list above.
+         */
+        public Builder public_dependency(List<Integer> public_dependency) {
+            Internal.checkElementsNotNull(public_dependency);
+            this.public_dependency = public_dependency;
+            return this;
+        }
+
+        /**
+         * Indexes of the weak imported files in the dependency list.
+         * For Google-internal migration only. Do not use.
+         */
+        public Builder weak_dependency(List<Integer> weak_dependency) {
+            Internal.checkElementsNotNull(weak_dependency);
+            this.weak_dependency = weak_dependency;
+            return this;
+        }
+
+        /**
+         * All top-level definitions in this file.
+         */
+        public Builder message_type(List<DescriptorProto> message_type) {
+            Internal.checkElementsNotNull(message_type);
+            this.message_type = message_type;
+            return this;
+        }
+
+        public Builder enum_type(List<EnumDescriptorProto> enum_type) {
+            Internal.checkElementsNotNull(enum_type);
+            this.enum_type = enum_type;
+            return this;
+        }
+
+        public Builder service(List<ServiceDescriptorProto> service) {
+            Internal.checkElementsNotNull(service);
+            this.service = service;
+            return this;
+        }
+
+        public Builder extension(List<FieldDescriptorProto> extension) {
+            Internal.checkElementsNotNull(extension);
+            this.extension = extension;
+            return this;
+        }
+
+        public Builder options(FileOptions options) {
+            this.options = options;
+            return this;
+        }
+
+        /**
+         * This field contains optional information about the original source code.
+         * You may safely remove this entire field without harming runtime
+         * functionality of the descriptors -- the information is needed only by
+         * development tools.
+         */
+        public Builder source_code_info(SourceCodeInfo source_code_info) {
+            this.source_code_info = source_code_info;
+            return this;
+        }
+
+        /**
+         * The syntax of the proto file.
+         * The supported values are "proto2" and "proto3".
+         */
+        public Builder syntax(String syntax) {
+            this.syntax = syntax;
+            return this;
+        }
+
+        @Override
+        public FileDescriptorProto build() {
+            return new FileDescriptorProto(name, package_, dependency, public_dependency, weak_dependency, message_type, enum_type, service, extension, options, source_code_info, syntax, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_FileDescriptorProto extends ProtoAdapter<FileDescriptorProto> {
+        public ProtoAdapter_FileDescriptorProto() {
+            super(FieldEncoding.LENGTH_DELIMITED, FileDescriptorProto.class);
+        }
+
+        @Override
+        public int encodedSize(FileDescriptorProto value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(2, value.package_)
+                    + ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(3, value.dependency)
+                    + ProtoAdapter.INT32.asRepeated().encodedSizeWithTag(10, value.public_dependency)
+                    + ProtoAdapter.INT32.asRepeated().encodedSizeWithTag(11, value.weak_dependency)
+                    + DescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(4, value.message_type)
+                    + EnumDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(5, value.enum_type)
+                    + ServiceDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(6, value.service)
+                    + FieldDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(7, value.extension)
+                    + FileOptions.ADAPTER.encodedSizeWithTag(8, value.options)
+                    + SourceCodeInfo.ADAPTER.encodedSizeWithTag(9, value.source_code_info)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(12, value.syntax)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, FileDescriptorProto value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name);
+            ProtoAdapter.STRING.encodeWithTag(writer, 2, value.package_);
+            ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 3, value.dependency);
+            ProtoAdapter.INT32.asRepeated().encodeWithTag(writer, 10, value.public_dependency);
+            ProtoAdapter.INT32.asRepeated().encodeWithTag(writer, 11, value.weak_dependency);
+            DescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 4, value.message_type);
+            EnumDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 5, value.enum_type);
+            ServiceDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 6, value.service);
+            FieldDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 7, value.extension);
+            FileOptions.ADAPTER.encodeWithTag(writer, 8, value.options);
+            SourceCodeInfo.ADAPTER.encodeWithTag(writer, 9, value.source_code_info);
+            ProtoAdapter.STRING.encodeWithTag(writer, 12, value.syntax);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public FileDescriptorProto decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 2:
+                        builder.package_(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 3:
+                        builder.dependency.add(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 4:
+                        builder.message_type.add(DescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 5:
+                        builder.enum_type.add(EnumDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 6:
+                        builder.service.add(ServiceDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 7:
+                        builder.extension.add(FieldDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 8:
+                        builder.options(FileOptions.ADAPTER.decode(reader));
+                        break;
+                    case 9:
+                        builder.source_code_info(SourceCodeInfo.ADAPTER.decode(reader));
+                        break;
+                    case 10:
+                        builder.public_dependency.add(ProtoAdapter.INT32.decode(reader));
+                        break;
+                    case 11:
+                        builder.weak_dependency.add(ProtoAdapter.INT32.decode(reader));
+                        break;
+                    case 12:
+                        builder.syntax(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public FileDescriptorProto redact(FileDescriptorProto value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.message_type, DescriptorProto.ADAPTER);
+            Internal.redactElements(builder.enum_type, EnumDescriptorProto.ADAPTER);
+            Internal.redactElements(builder.service, ServiceDescriptorProto.ADAPTER);
+            Internal.redactElements(builder.extension, FieldDescriptorProto.ADAPTER);
+            if (builder.options != null) {
+                builder.options = FileOptions.ADAPTER.redact(builder.options);
+            }
+            if (builder.source_code_info != null) {
+                builder.source_code_info = SourceCodeInfo.ADAPTER.redact(builder.source_code_info);
+            }
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/FileDescriptorSet.java b/app/src/main/java/com/google/protobuf/FileDescriptorSet.java
new file mode 100644
index 0000000..94e6bf1
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/FileDescriptorSet.java
@@ -0,0 +1,148 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+/**
+ * The protocol compiler can output a FileDescriptorSet containing the .proto
+ * files it parses.
+ */
+public final class FileDescriptorSet extends Message<FileDescriptorSet, FileDescriptorSet.Builder> {
+    public static final ProtoAdapter<FileDescriptorSet> ADAPTER = new ProtoAdapter_FileDescriptorSet();
+
+    private static final long serialVersionUID = 0L;
+
+    @WireField(
+            tag = 1,
+            adapter = "com.google.protobuf.FileDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<FileDescriptorProto> file;
+
+    public FileDescriptorSet(List<FileDescriptorProto> file) {
+        this(file, ByteString.EMPTY);
+    }
+
+    public FileDescriptorSet(List<FileDescriptorProto> file, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.file = Internal.immutableCopyOf("file", file);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.file = Internal.copyOf("file", file);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof FileDescriptorSet)) {
+            return false;
+        }
+        FileDescriptorSet o = (FileDescriptorSet) other;
+        return unknownFields().equals(o.unknownFields())
+                && file.equals(o.file);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + file.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (!file.isEmpty()) {
+            builder.append(", file=").append(file);
+        }
+        return builder.replace(0, 2, "FileDescriptorSet{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<FileDescriptorSet, Builder> {
+        public List<FileDescriptorProto> file;
+
+        public Builder() {
+            file = Internal.newMutableList();
+        }
+
+        public Builder file(List<FileDescriptorProto> file) {
+            Internal.checkElementsNotNull(file);
+            this.file = file;
+            return this;
+        }
+
+        @Override
+        public FileDescriptorSet build() {
+            return new FileDescriptorSet(file, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_FileDescriptorSet extends ProtoAdapter<FileDescriptorSet> {
+        public ProtoAdapter_FileDescriptorSet() {
+            super(FieldEncoding.LENGTH_DELIMITED, FileDescriptorSet.class);
+        }
+
+        @Override
+        public int encodedSize(FileDescriptorSet value) {
+            return FileDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(1, value.file)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, FileDescriptorSet value) throws IOException {
+            FileDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 1, value.file);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public FileDescriptorSet decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.file.add(FileDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public FileDescriptorSet redact(FileDescriptorSet value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.file, FileDescriptorProto.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/FileOptions.java b/app/src/main/java/com/google/protobuf/FileOptions.java
new file mode 100644
index 0000000..423f587
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/FileOptions.java
@@ -0,0 +1,776 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.EnumAdapter;
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireEnum;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+/**
+ * ===================================================================
+ * Options
+ * Each of the definitions above may have "options" attached.  These are
+ * just annotations which may cause code to be generated slightly differently
+ * or may contain hints for code that manipulates protocol messages.
+ * <p>
+ * Clients may define custom options as extensions of the *Options messages.
+ * These extensions may not yet be known at parsing time, so the parser cannot
+ * store the values in them.  Instead it stores them in a field in the *Options
+ * message called uninterpreted_option. This field must have the same name
+ * across all *Options messages. We then use this field to populate the
+ * extensions when we build a descriptor, at which point all protos have been
+ * parsed and so all extensions are known.
+ * <p>
+ * Extension numbers for custom options may be chosen as follows:
+ * * For options which will only be used within a single application or
+ * organization, or for experimental options, use field numbers 50000
+ * through 99999.  It is up to you to ensure that you do not use the
+ * same number for multiple options.
+ * * For options which will be published and used publicly by multiple
+ * independent entities, e-mail protobuf-global-extension-registry@google.com
+ * to reserve extension numbers. Simply provide your project name (e.g.
+ * Objective-C plugin) and your project website (if available) -- there's no
+ * need to explain how you intend to use them. Usually you only need one
+ * extension number. You can declare multiple options with only one extension
+ * number by putting them in a sub-message. See the Custom Options section of
+ * the docs for examples:
+ * https://developers.google.com/protocol-buffers/docs/proto#options
+ * If this turns out to be popular, a web service will be set up
+ * to automatically assign option numbers.
+ */
+public final class FileOptions extends Message<FileOptions, FileOptions.Builder> {
+    public static final ProtoAdapter<FileOptions> ADAPTER = new ProtoAdapter_FileOptions();
+    public static final String DEFAULT_JAVA_PACKAGE = "";
+    public static final String DEFAULT_JAVA_OUTER_CLASSNAME = "";
+    public static final Boolean DEFAULT_JAVA_MULTIPLE_FILES = false;
+    public static final Boolean DEFAULT_JAVA_GENERATE_EQUALS_AND_HASH = false;
+    public static final Boolean DEFAULT_JAVA_STRING_CHECK_UTF8 = false;
+    public static final OptimizeMode DEFAULT_OPTIMIZE_FOR = OptimizeMode.SPEED;
+    public static final String DEFAULT_GO_PACKAGE = "";
+    public static final Boolean DEFAULT_CC_GENERIC_SERVICES = false;
+    public static final Boolean DEFAULT_JAVA_GENERIC_SERVICES = false;
+    public static final Boolean DEFAULT_PY_GENERIC_SERVICES = false;
+    public static final Boolean DEFAULT_DEPRECATED = false;
+    public static final Boolean DEFAULT_CC_ENABLE_ARENAS = false;
+    public static final String DEFAULT_OBJC_CLASS_PREFIX = "";
+    public static final String DEFAULT_CSHARP_NAMESPACE = "";
+    private static final long serialVersionUID = 0L;
+    /**
+     * Sets the Java package where classes generated from this .proto will be
+     * placed.  By default, the proto package is used, but this is often
+     * inappropriate because proto packages do not normally start with backwards
+     * domain names.
+     */
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String java_package;
+
+    /**
+     * If set, all the classes from the .proto file are wrapped in a single
+     * outer class with the given name.  This applies to both Proto1
+     * (equivalent to the old "--one_java_file" option) and Proto2 (where
+     * a .proto always translates to a single class, but you may want to
+     * explicitly choose the class name).
+     */
+    @WireField(
+            tag = 8,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String java_outer_classname;
+
+    /**
+     * If set true, then the Java code generator will generate a separate .java
+     * file for each top-level message, enum, and service defined in the .proto
+     * file.  Thus, these types will *not* be nested inside the outer class
+     * named by java_outer_classname.  However, the outer class will still be
+     * generated to contain the file's getDescriptor() method as well as any
+     * top-level extensions defined in the file.
+     */
+    @WireField(
+            tag = 10,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean java_multiple_files;
+
+    /**
+     * If set true, then the Java code generator will generate equals() and
+     * hashCode() methods for all messages defined in the .proto file.
+     * - In the full runtime, this is purely a speed optimization, as the
+     * AbstractMessage base class includes reflection-based implementations of
+     * these methods.
+     * - In the lite runtime, setting this option changes the semantics of
+     * equals() and hashCode() to more closely match those of the full runtime;
+     * the generated methods compute their results based on field values rather
+     * than object identity. (Implementations should not assume that hashcodes
+     * will be consistent across runtimes or versions of the protocol compiler.)
+     */
+    @WireField(
+            tag = 20,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean java_generate_equals_and_hash;
+
+    /**
+     * If set true, then the Java2 code generator will generate code that
+     * throws an exception whenever an attempt is made to assign a non-UTF-8
+     * byte sequence to a string field.
+     * Message reflection will do the same.
+     * However, an extension field still accepts non-UTF-8 byte sequences.
+     * This option has no effect on when used with the lite runtime.
+     */
+    @WireField(
+            tag = 27,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean java_string_check_utf8;
+
+    @WireField(
+            tag = 9,
+            adapter = "com.google.protobuf.FileOptions$OptimizeMode#ADAPTER"
+    )
+    public final OptimizeMode optimize_for;
+
+    /**
+     * Sets the Go package where structs generated from this .proto will be
+     * placed. If omitted, the Go package will be derived from the following:
+     * - The basename of the package import path, if provided.
+     * - Otherwise, the package statement in the .proto file, if present.
+     * - Otherwise, the basename of the .proto file, without extension.
+     */
+    @WireField(
+            tag = 11,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String go_package;
+
+    /**
+     * Should generic services be generated in each language?  "Generic" services
+     * are not specific to any particular RPC system.  They are generated by the
+     * main code generators in each language (without additional plugins).
+     * Generic services were the only kind of service generation supported by
+     * early versions of google.protobuf.
+     * <p>
+     * Generic services are now considered deprecated in favor of using plugins
+     * that generate code specific to your particular RPC system.  Therefore,
+     * these default to false.  Old code which depends on generic services should
+     * explicitly set them to true.
+     */
+    @WireField(
+            tag = 16,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean cc_generic_services;
+
+    @WireField(
+            tag = 17,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean java_generic_services;
+
+    @WireField(
+            tag = 18,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean py_generic_services;
+
+    /**
+     * Is this file deprecated?
+     * Depending on the target platform, this can emit Deprecated annotations
+     * for everything in the file, or it will be completely ignored; in the very
+     * least, this is a formalization for deprecating files.
+     */
+    @WireField(
+            tag = 23,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean deprecated;
+
+    /**
+     * Enables the use of arenas for the proto messages in this file. This applies
+     * only to generated classes for C++.
+     */
+    @WireField(
+            tag = 31,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean cc_enable_arenas;
+
+    /**
+     * Sets the objective c class prefix which is prepended to all objective c
+     * generated classes from this .proto. There is no default.
+     */
+    @WireField(
+            tag = 36,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String objc_class_prefix;
+
+    /**
+     * Namespace for generated classes; defaults to the package.
+     */
+    @WireField(
+            tag = 37,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String csharp_namespace;
+
+    /**
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    @WireField(
+            tag = 999,
+            adapter = "com.google.protobuf.UninterpretedOption#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<UninterpretedOption> uninterpreted_option;
+
+    public FileOptions(String java_package, String java_outer_classname, Boolean java_multiple_files,
+                       Boolean java_generate_equals_and_hash, Boolean java_string_check_utf8,
+                       OptimizeMode optimize_for, String go_package, Boolean cc_generic_services,
+                       Boolean java_generic_services, Boolean py_generic_services, Boolean deprecated,
+                       Boolean cc_enable_arenas, String objc_class_prefix, String csharp_namespace,
+                       List<UninterpretedOption> uninterpreted_option) {
+        this(java_package, java_outer_classname, java_multiple_files, java_generate_equals_and_hash, java_string_check_utf8, optimize_for, go_package, cc_generic_services, java_generic_services, py_generic_services, deprecated, cc_enable_arenas, objc_class_prefix, csharp_namespace, uninterpreted_option, ByteString.EMPTY);
+    }
+
+    public FileOptions(String java_package, String java_outer_classname, Boolean java_multiple_files,
+                       Boolean java_generate_equals_and_hash, Boolean java_string_check_utf8,
+                       OptimizeMode optimize_for, String go_package, Boolean cc_generic_services,
+                       Boolean java_generic_services, Boolean py_generic_services, Boolean deprecated,
+                       Boolean cc_enable_arenas, String objc_class_prefix, String csharp_namespace,
+                       List<UninterpretedOption> uninterpreted_option, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.java_package = java_package;
+        this.java_outer_classname = java_outer_classname;
+        this.java_multiple_files = java_multiple_files;
+        this.java_generate_equals_and_hash = java_generate_equals_and_hash;
+        this.java_string_check_utf8 = java_string_check_utf8;
+        this.optimize_for = optimize_for;
+        this.go_package = go_package;
+        this.cc_generic_services = cc_generic_services;
+        this.java_generic_services = java_generic_services;
+        this.py_generic_services = py_generic_services;
+        this.deprecated = deprecated;
+        this.cc_enable_arenas = cc_enable_arenas;
+        this.objc_class_prefix = objc_class_prefix;
+        this.csharp_namespace = csharp_namespace;
+        this.uninterpreted_option = Internal.immutableCopyOf("uninterpreted_option", uninterpreted_option);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.java_package = java_package;
+        builder.java_outer_classname = java_outer_classname;
+        builder.java_multiple_files = java_multiple_files;
+        builder.java_generate_equals_and_hash = java_generate_equals_and_hash;
+        builder.java_string_check_utf8 = java_string_check_utf8;
+        builder.optimize_for = optimize_for;
+        builder.go_package = go_package;
+        builder.cc_generic_services = cc_generic_services;
+        builder.java_generic_services = java_generic_services;
+        builder.py_generic_services = py_generic_services;
+        builder.deprecated = deprecated;
+        builder.cc_enable_arenas = cc_enable_arenas;
+        builder.objc_class_prefix = objc_class_prefix;
+        builder.csharp_namespace = csharp_namespace;
+        builder.uninterpreted_option = Internal.copyOf("uninterpreted_option", uninterpreted_option);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof FileOptions)) {
+            return false;
+        }
+        FileOptions o = (FileOptions) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(java_package, o.java_package)
+                && Internal.equals(java_outer_classname, o.java_outer_classname)
+                && Internal.equals(java_multiple_files, o.java_multiple_files)
+                && Internal.equals(java_generate_equals_and_hash, o.java_generate_equals_and_hash)
+                && Internal.equals(java_string_check_utf8, o.java_string_check_utf8)
+                && Internal.equals(optimize_for, o.optimize_for)
+                && Internal.equals(go_package, o.go_package)
+                && Internal.equals(cc_generic_services, o.cc_generic_services)
+                && Internal.equals(java_generic_services, o.java_generic_services)
+                && Internal.equals(py_generic_services, o.py_generic_services)
+                && Internal.equals(deprecated, o.deprecated)
+                && Internal.equals(cc_enable_arenas, o.cc_enable_arenas)
+                && Internal.equals(objc_class_prefix, o.objc_class_prefix)
+                && Internal.equals(csharp_namespace, o.csharp_namespace)
+                && uninterpreted_option.equals(o.uninterpreted_option);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (java_package != null ? java_package.hashCode() : 0);
+            result = result * 37 + (java_outer_classname != null ? java_outer_classname.hashCode() : 0);
+            result = result * 37 + (java_multiple_files != null ? java_multiple_files.hashCode() : 0);
+            result = result * 37 + (java_generate_equals_and_hash != null ? java_generate_equals_and_hash.hashCode() : 0);
+            result = result * 37 + (java_string_check_utf8 != null ? java_string_check_utf8.hashCode() : 0);
+            result = result * 37 + (optimize_for != null ? optimize_for.hashCode() : 0);
+            result = result * 37 + (go_package != null ? go_package.hashCode() : 0);
+            result = result * 37 + (cc_generic_services != null ? cc_generic_services.hashCode() : 0);
+            result = result * 37 + (java_generic_services != null ? java_generic_services.hashCode() : 0);
+            result = result * 37 + (py_generic_services != null ? py_generic_services.hashCode() : 0);
+            result = result * 37 + (deprecated != null ? deprecated.hashCode() : 0);
+            result = result * 37 + (cc_enable_arenas != null ? cc_enable_arenas.hashCode() : 0);
+            result = result * 37 + (objc_class_prefix != null ? objc_class_prefix.hashCode() : 0);
+            result = result * 37 + (csharp_namespace != null ? csharp_namespace.hashCode() : 0);
+            result = result * 37 + uninterpreted_option.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (java_package != null) {
+            builder.append(", java_package=").append(java_package);
+        }
+        if (java_outer_classname != null) {
+            builder.append(", java_outer_classname=").append(java_outer_classname);
+        }
+        if (java_multiple_files != null) {
+            builder.append(", java_multiple_files=").append(java_multiple_files);
+        }
+        if (java_generate_equals_and_hash != null) {
+            builder.append(", java_generate_equals_and_hash=").append(java_generate_equals_and_hash);
+        }
+        if (java_string_check_utf8 != null) {
+            builder.append(", java_string_check_utf8=").append(java_string_check_utf8);
+        }
+        if (optimize_for != null) {
+            builder.append(", optimize_for=").append(optimize_for);
+        }
+        if (go_package != null) {
+            builder.append(", go_package=").append(go_package);
+        }
+        if (cc_generic_services != null) {
+            builder.append(", cc_generic_services=").append(cc_generic_services);
+        }
+        if (java_generic_services != null) {
+            builder.append(", java_generic_services=").append(java_generic_services);
+        }
+        if (py_generic_services != null) {
+            builder.append(", py_generic_services=").append(py_generic_services);
+        }
+        if (deprecated != null) {
+            builder.append(", deprecated=").append(deprecated);
+        }
+        if (cc_enable_arenas != null) {
+            builder.append(", cc_enable_arenas=").append(cc_enable_arenas);
+        }
+        if (objc_class_prefix != null) {
+            builder.append(", objc_class_prefix=").append(objc_class_prefix);
+        }
+        if (csharp_namespace != null) {
+            builder.append(", csharp_namespace=").append(csharp_namespace);
+        }
+        if (!uninterpreted_option.isEmpty()) {
+            builder.append(", uninterpreted_option=").append(uninterpreted_option);
+        }
+        return builder.replace(0, 2, "FileOptions{").append('}').toString();
+    }
+
+    /**
+     * Generated classes can be optimized for speed or code size.
+     */
+    public enum OptimizeMode implements WireEnum {
+        /**
+         * Generate complete code for parsing, serialization,
+         */
+        SPEED(1),
+
+        /**
+         * etc.
+         * Use ReflectionOps to implement these methods.
+         */
+        CODE_SIZE(2),
+
+        /**
+         * Generate code using MessageLite and the lite runtime.
+         */
+        LITE_RUNTIME(3);
+
+        public static final ProtoAdapter<OptimizeMode> ADAPTER = new ProtoAdapter_OptimizeMode();
+
+        private final int value;
+
+        OptimizeMode(int value) {
+            this.value = value;
+        }
+
+        /**
+         * Return the constant for {@code value} or null.
+         */
+        public static OptimizeMode fromValue(int value) {
+            switch (value) {
+                case 1:
+                    return SPEED;
+                case 2:
+                    return CODE_SIZE;
+                case 3:
+                    return LITE_RUNTIME;
+                default:
+                    return null;
+            }
+        }
+
+        @Override
+        public int getValue() {
+            return value;
+        }
+
+        private static final class ProtoAdapter_OptimizeMode extends EnumAdapter<OptimizeMode> {
+            ProtoAdapter_OptimizeMode() {
+                super(OptimizeMode.class);
+            }
+
+            @Override
+            protected OptimizeMode fromValue(int value) {
+                return OptimizeMode.fromValue(value);
+            }
+        }
+    }
+
+    public static final class Builder extends Message.Builder<FileOptions, Builder> {
+        public String java_package;
+
+        public String java_outer_classname;
+
+        public Boolean java_multiple_files;
+
+        public Boolean java_generate_equals_and_hash;
+
+        public Boolean java_string_check_utf8;
+
+        public OptimizeMode optimize_for;
+
+        public String go_package;
+
+        public Boolean cc_generic_services;
+
+        public Boolean java_generic_services;
+
+        public Boolean py_generic_services;
+
+        public Boolean deprecated;
+
+        public Boolean cc_enable_arenas;
+
+        public String objc_class_prefix;
+
+        public String csharp_namespace;
+
+        public List<UninterpretedOption> uninterpreted_option;
+
+        public Builder() {
+            uninterpreted_option = Internal.newMutableList();
+        }
+
+        /**
+         * Sets the Java package where classes generated from this .proto will be
+         * placed.  By default, the proto package is used, but this is often
+         * inappropriate because proto packages do not normally start with backwards
+         * domain names.
+         */
+        public Builder java_package(String java_package) {
+            this.java_package = java_package;
+            return this;
+        }
+
+        /**
+         * If set, all the classes from the .proto file are wrapped in a single
+         * outer class with the given name.  This applies to both Proto1
+         * (equivalent to the old "--one_java_file" option) and Proto2 (where
+         * a .proto always translates to a single class, but you may want to
+         * explicitly choose the class name).
+         */
+        public Builder java_outer_classname(String java_outer_classname) {
+            this.java_outer_classname = java_outer_classname;
+            return this;
+        }
+
+        /**
+         * If set true, then the Java code generator will generate a separate .java
+         * file for each top-level message, enum, and service defined in the .proto
+         * file.  Thus, these types will *not* be nested inside the outer class
+         * named by java_outer_classname.  However, the outer class will still be
+         * generated to contain the file's getDescriptor() method as well as any
+         * top-level extensions defined in the file.
+         */
+        public Builder java_multiple_files(Boolean java_multiple_files) {
+            this.java_multiple_files = java_multiple_files;
+            return this;
+        }
+
+        /**
+         * If set true, then the Java code generator will generate equals() and
+         * hashCode() methods for all messages defined in the .proto file.
+         * - In the full runtime, this is purely a speed optimization, as the
+         * AbstractMessage base class includes reflection-based implementations of
+         * these methods.
+         * - In the lite runtime, setting this option changes the semantics of
+         * equals() and hashCode() to more closely match those of the full runtime;
+         * the generated methods compute their results based on field values rather
+         * than object identity. (Implementations should not assume that hashcodes
+         * will be consistent across runtimes or versions of the protocol compiler.)
+         */
+        public Builder java_generate_equals_and_hash(Boolean java_generate_equals_and_hash) {
+            this.java_generate_equals_and_hash = java_generate_equals_and_hash;
+            return this;
+        }
+
+        /**
+         * If set true, then the Java2 code generator will generate code that
+         * throws an exception whenever an attempt is made to assign a non-UTF-8
+         * byte sequence to a string field.
+         * Message reflection will do the same.
+         * However, an extension field still accepts non-UTF-8 byte sequences.
+         * This option has no effect on when used with the lite runtime.
+         */
+        public Builder java_string_check_utf8(Boolean java_string_check_utf8) {
+            this.java_string_check_utf8 = java_string_check_utf8;
+            return this;
+        }
+
+        public Builder optimize_for(OptimizeMode optimize_for) {
+            this.optimize_for = optimize_for;
+            return this;
+        }
+
+        /**
+         * Sets the Go package where structs generated from this .proto will be
+         * placed. If omitted, the Go package will be derived from the following:
+         * - The basename of the package import path, if provided.
+         * - Otherwise, the package statement in the .proto file, if present.
+         * - Otherwise, the basename of the .proto file, without extension.
+         */
+        public Builder go_package(String go_package) {
+            this.go_package = go_package;
+            return this;
+        }
+
+        /**
+         * Should generic services be generated in each language?  "Generic" services
+         * are not specific to any particular RPC system.  They are generated by the
+         * main code generators in each language (without additional plugins).
+         * Generic services were the only kind of service generation supported by
+         * early versions of google.protobuf.
+         * <p>
+         * Generic services are now considered deprecated in favor of using plugins
+         * that generate code specific to your particular RPC system.  Therefore,
+         * these default to false.  Old code which depends on generic services should
+         * explicitly set them to true.
+         */
+        public Builder cc_generic_services(Boolean cc_generic_services) {
+            this.cc_generic_services = cc_generic_services;
+            return this;
+        }
+
+        public Builder java_generic_services(Boolean java_generic_services) {
+            this.java_generic_services = java_generic_services;
+            return this;
+        }
+
+        public Builder py_generic_services(Boolean py_generic_services) {
+            this.py_generic_services = py_generic_services;
+            return this;
+        }
+
+        /**
+         * Is this file deprecated?
+         * Depending on the target platform, this can emit Deprecated annotations
+         * for everything in the file, or it will be completely ignored; in the very
+         * least, this is a formalization for deprecating files.
+         */
+        public Builder deprecated(Boolean deprecated) {
+            this.deprecated = deprecated;
+            return this;
+        }
+
+        /**
+         * Enables the use of arenas for the proto messages in this file. This applies
+         * only to generated classes for C++.
+         */
+        public Builder cc_enable_arenas(Boolean cc_enable_arenas) {
+            this.cc_enable_arenas = cc_enable_arenas;
+            return this;
+        }
+
+        /**
+         * Sets the objective c class prefix which is prepended to all objective c
+         * generated classes from this .proto. There is no default.
+         */
+        public Builder objc_class_prefix(String objc_class_prefix) {
+            this.objc_class_prefix = objc_class_prefix;
+            return this;
+        }
+
+        /**
+         * Namespace for generated classes; defaults to the package.
+         */
+        public Builder csharp_namespace(String csharp_namespace) {
+            this.csharp_namespace = csharp_namespace;
+            return this;
+        }
+
+        /**
+         * The parser stores options it doesn't recognize here. See above.
+         */
+        public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+            Internal.checkElementsNotNull(uninterpreted_option);
+            this.uninterpreted_option = uninterpreted_option;
+            return this;
+        }
+
+        @Override
+        public FileOptions build() {
+            return new FileOptions(java_package, java_outer_classname, java_multiple_files, java_generate_equals_and_hash, java_string_check_utf8, optimize_for, go_package, cc_generic_services, java_generic_services, py_generic_services, deprecated, cc_enable_arenas, objc_class_prefix, csharp_namespace, uninterpreted_option, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_FileOptions extends ProtoAdapter<FileOptions> {
+        public ProtoAdapter_FileOptions() {
+            super(FieldEncoding.LENGTH_DELIMITED, FileOptions.class);
+        }
+
+        @Override
+        public int encodedSize(FileOptions value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.java_package)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(8, value.java_outer_classname)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(10, value.java_multiple_files)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(20, value.java_generate_equals_and_hash)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(27, value.java_string_check_utf8)
+                    + OptimizeMode.ADAPTER.encodedSizeWithTag(9, value.optimize_for)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(11, value.go_package)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(16, value.cc_generic_services)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(17, value.java_generic_services)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(18, value.py_generic_services)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(23, value.deprecated)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(31, value.cc_enable_arenas)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(36, value.objc_class_prefix)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(37, value.csharp_namespace)
+                    + UninterpretedOption.ADAPTER.asRepeated().encodedSizeWithTag(999, value.uninterpreted_option)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, FileOptions value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.java_package);
+            ProtoAdapter.STRING.encodeWithTag(writer, 8, value.java_outer_classname);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 10, value.java_multiple_files);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 20, value.java_generate_equals_and_hash);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 27, value.java_string_check_utf8);
+            OptimizeMode.ADAPTER.encodeWithTag(writer, 9, value.optimize_for);
+            ProtoAdapter.STRING.encodeWithTag(writer, 11, value.go_package);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 16, value.cc_generic_services);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 17, value.java_generic_services);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 18, value.py_generic_services);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 23, value.deprecated);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 31, value.cc_enable_arenas);
+            ProtoAdapter.STRING.encodeWithTag(writer, 36, value.objc_class_prefix);
+            ProtoAdapter.STRING.encodeWithTag(writer, 37, value.csharp_namespace);
+            UninterpretedOption.ADAPTER.asRepeated().encodeWithTag(writer, 999, value.uninterpreted_option);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public FileOptions decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.java_package(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 8:
+                        builder.java_outer_classname(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 9: {
+                        try {
+                            builder.optimize_for(OptimizeMode.ADAPTER.decode(reader));
+                        } catch (ProtoAdapter.EnumConstantNotFoundException e) {
+                            builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
+                        }
+                        break;
+                    }
+                    case 10:
+                        builder.java_multiple_files(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 11:
+                        builder.go_package(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 16:
+                        builder.cc_generic_services(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 17:
+                        builder.java_generic_services(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 18:
+                        builder.py_generic_services(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 20:
+                        builder.java_generate_equals_and_hash(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 23:
+                        builder.deprecated(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 27:
+                        builder.java_string_check_utf8(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 31:
+                        builder.cc_enable_arenas(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 36:
+                        builder.objc_class_prefix(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 37:
+                        builder.csharp_namespace(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 999:
+                        builder.uninterpreted_option.add(UninterpretedOption.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public FileOptions redact(FileOptions value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.uninterpreted_option, UninterpretedOption.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/MessageOptions.java b/app/src/main/java/com/google/protobuf/MessageOptions.java
new file mode 100644
index 0000000..a0a5c2a
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/MessageOptions.java
@@ -0,0 +1,363 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+public final class MessageOptions extends Message<MessageOptions, MessageOptions.Builder> {
+    public static final ProtoAdapter<MessageOptions> ADAPTER = new ProtoAdapter_MessageOptions();
+    public static final Boolean DEFAULT_MESSAGE_SET_WIRE_FORMAT = false;
+    public static final Boolean DEFAULT_NO_STANDARD_DESCRIPTOR_ACCESSOR = false;
+    public static final Boolean DEFAULT_DEPRECATED = false;
+    public static final Boolean DEFAULT_MAP_ENTRY = false;
+    private static final long serialVersionUID = 0L;
+    /**
+     * Set true to use the old proto1 MessageSet wire format for extensions.
+     * This is provided for backwards-compatibility with the MessageSet wire
+     * format.  You should not use this for any other reason:  It's less
+     * efficient, has fewer features, and is more complicated.
+     * <p>
+     * The message must be defined exactly as follows:
+     * message Foo {
+     * option message_set_wire_format = true;
+     * extensions 4 to max;
+     * }
+     * Note that the message cannot have any defined fields; MessageSets only
+     * have extensions.
+     * <p>
+     * All extensions of your type must be singular messages; e.g. they cannot
+     * be int32s, enums, or repeated messages.
+     * <p>
+     * Because this is an option, the above two restrictions are not enforced by
+     * the protocol compiler.
+     */
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean message_set_wire_format;
+
+    /**
+     * Disables the generation of the standard "descriptor()" accessor, which can
+     * conflict with a field of the same name.  This is meant to make migration
+     * from proto1 easier; new code should avoid fields named "descriptor".
+     */
+    @WireField(
+            tag = 2,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean no_standard_descriptor_accessor;
+
+    /**
+     * Is this message deprecated?
+     * Depending on the target platform, this can emit Deprecated annotations
+     * for the message, or it will be completely ignored; in the very least,
+     * this is a formalization for deprecating messages.
+     */
+    @WireField(
+            tag = 3,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean deprecated;
+
+    /**
+     * Whether the message is an automatically generated map entry type for the
+     * maps field.
+     * <p>
+     * For maps fields:
+     * map<KeyType, ValueType> map_field = 1;
+     * The parsed descriptor looks like:
+     * message MapFieldEntry {
+     * option map_entry = true;
+     * optional KeyType key = 1;
+     * optional ValueType value = 2;
+     * }
+     * repeated MapFieldEntry map_field = 1;
+     * <p>
+     * Implementations may choose not to generate the map_entry=true message, but
+     * use a native map in the target language to hold the keys and values.
+     * The reflection APIs in such implementions still need to work as
+     * if the field is a repeated message field.
+     * <p>
+     * NOTE: Do not set the option in .proto files. Always use the maps syntax
+     * instead. The option should only be implicitly set by the proto compiler
+     * parser.
+     */
+    @WireField(
+            tag = 7,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean map_entry;
+
+    /**
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    @WireField(
+            tag = 999,
+            adapter = "com.google.protobuf.UninterpretedOption#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<UninterpretedOption> uninterpreted_option;
+
+    public MessageOptions(Boolean message_set_wire_format, Boolean no_standard_descriptor_accessor,
+                          Boolean deprecated, Boolean map_entry, List<UninterpretedOption> uninterpreted_option) {
+        this(message_set_wire_format, no_standard_descriptor_accessor, deprecated, map_entry, uninterpreted_option, ByteString.EMPTY);
+    }
+
+    public MessageOptions(Boolean message_set_wire_format, Boolean no_standard_descriptor_accessor,
+                          Boolean deprecated, Boolean map_entry, List<UninterpretedOption> uninterpreted_option,
+                          ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.message_set_wire_format = message_set_wire_format;
+        this.no_standard_descriptor_accessor = no_standard_descriptor_accessor;
+        this.deprecated = deprecated;
+        this.map_entry = map_entry;
+        this.uninterpreted_option = Internal.immutableCopyOf("uninterpreted_option", uninterpreted_option);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.message_set_wire_format = message_set_wire_format;
+        builder.no_standard_descriptor_accessor = no_standard_descriptor_accessor;
+        builder.deprecated = deprecated;
+        builder.map_entry = map_entry;
+        builder.uninterpreted_option = Internal.copyOf("uninterpreted_option", uninterpreted_option);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof MessageOptions)) {
+            return false;
+        }
+        MessageOptions o = (MessageOptions) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(message_set_wire_format, o.message_set_wire_format)
+                && Internal.equals(no_standard_descriptor_accessor, o.no_standard_descriptor_accessor)
+                && Internal.equals(deprecated, o.deprecated)
+                && Internal.equals(map_entry, o.map_entry)
+                && uninterpreted_option.equals(o.uninterpreted_option);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (message_set_wire_format != null ? message_set_wire_format.hashCode() : 0);
+            result = result * 37 + (no_standard_descriptor_accessor != null ? no_standard_descriptor_accessor.hashCode() : 0);
+            result = result * 37 + (deprecated != null ? deprecated.hashCode() : 0);
+            result = result * 37 + (map_entry != null ? map_entry.hashCode() : 0);
+            result = result * 37 + uninterpreted_option.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (message_set_wire_format != null) {
+            builder.append(", message_set_wire_format=").append(message_set_wire_format);
+        }
+        if (no_standard_descriptor_accessor != null) {
+            builder.append(", no_standard_descriptor_accessor=").append(no_standard_descriptor_accessor);
+        }
+        if (deprecated != null) {
+            builder.append(", deprecated=").append(deprecated);
+        }
+        if (map_entry != null) {
+            builder.append(", map_entry=").append(map_entry);
+        }
+        if (!uninterpreted_option.isEmpty()) {
+            builder.append(", uninterpreted_option=").append(uninterpreted_option);
+        }
+        return builder.replace(0, 2, "MessageOptions{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<MessageOptions, Builder> {
+        public Boolean message_set_wire_format;
+
+        public Boolean no_standard_descriptor_accessor;
+
+        public Boolean deprecated;
+
+        public Boolean map_entry;
+
+        public List<UninterpretedOption> uninterpreted_option;
+
+        public Builder() {
+            uninterpreted_option = Internal.newMutableList();
+        }
+
+        /**
+         * Set true to use the old proto1 MessageSet wire format for extensions.
+         * This is provided for backwards-compatibility with the MessageSet wire
+         * format.  You should not use this for any other reason:  It's less
+         * efficient, has fewer features, and is more complicated.
+         * <p>
+         * The message must be defined exactly as follows:
+         * message Foo {
+         * option message_set_wire_format = true;
+         * extensions 4 to max;
+         * }
+         * Note that the message cannot have any defined fields; MessageSets only
+         * have extensions.
+         * <p>
+         * All extensions of your type must be singular messages; e.g. they cannot
+         * be int32s, enums, or repeated messages.
+         * <p>
+         * Because this is an option, the above two restrictions are not enforced by
+         * the protocol compiler.
+         */
+        public Builder message_set_wire_format(Boolean message_set_wire_format) {
+            this.message_set_wire_format = message_set_wire_format;
+            return this;
+        }
+
+        /**
+         * Disables the generation of the standard "descriptor()" accessor, which can
+         * conflict with a field of the same name.  This is meant to make migration
+         * from proto1 easier; new code should avoid fields named "descriptor".
+         */
+        public Builder no_standard_descriptor_accessor(Boolean no_standard_descriptor_accessor) {
+            this.no_standard_descriptor_accessor = no_standard_descriptor_accessor;
+            return this;
+        }
+
+        /**
+         * Is this message deprecated?
+         * Depending on the target platform, this can emit Deprecated annotations
+         * for the message, or it will be completely ignored; in the very least,
+         * this is a formalization for deprecating messages.
+         */
+        public Builder deprecated(Boolean deprecated) {
+            this.deprecated = deprecated;
+            return this;
+        }
+
+        /**
+         * Whether the message is an automatically generated map entry type for the
+         * maps field.
+         * <p>
+         * For maps fields:
+         * map<KeyType, ValueType> map_field = 1;
+         * The parsed descriptor looks like:
+         * message MapFieldEntry {
+         * option map_entry = true;
+         * optional KeyType key = 1;
+         * optional ValueType value = 2;
+         * }
+         * repeated MapFieldEntry map_field = 1;
+         * <p>
+         * Implementations may choose not to generate the map_entry=true message, but
+         * use a native map in the target language to hold the keys and values.
+         * The reflection APIs in such implementions still need to work as
+         * if the field is a repeated message field.
+         * <p>
+         * NOTE: Do not set the option in .proto files. Always use the maps syntax
+         * instead. The option should only be implicitly set by the proto compiler
+         * parser.
+         */
+        public Builder map_entry(Boolean map_entry) {
+            this.map_entry = map_entry;
+            return this;
+        }
+
+        /**
+         * The parser stores options it doesn't recognize here. See above.
+         */
+        public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+            Internal.checkElementsNotNull(uninterpreted_option);
+            this.uninterpreted_option = uninterpreted_option;
+            return this;
+        }
+
+        @Override
+        public MessageOptions build() {
+            return new MessageOptions(message_set_wire_format, no_standard_descriptor_accessor, deprecated, map_entry, uninterpreted_option, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_MessageOptions extends ProtoAdapter<MessageOptions> {
+        public ProtoAdapter_MessageOptions() {
+            super(FieldEncoding.LENGTH_DELIMITED, MessageOptions.class);
+        }
+
+        @Override
+        public int encodedSize(MessageOptions value) {
+            return ProtoAdapter.BOOL.encodedSizeWithTag(1, value.message_set_wire_format)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(2, value.no_standard_descriptor_accessor)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(3, value.deprecated)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(7, value.map_entry)
+                    + UninterpretedOption.ADAPTER.asRepeated().encodedSizeWithTag(999, value.uninterpreted_option)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, MessageOptions value) throws IOException {
+            ProtoAdapter.BOOL.encodeWithTag(writer, 1, value.message_set_wire_format);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 2, value.no_standard_descriptor_accessor);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 3, value.deprecated);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 7, value.map_entry);
+            UninterpretedOption.ADAPTER.asRepeated().encodeWithTag(writer, 999, value.uninterpreted_option);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public MessageOptions decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.message_set_wire_format(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 2:
+                        builder.no_standard_descriptor_accessor(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 3:
+                        builder.deprecated(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 7:
+                        builder.map_entry(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 999:
+                        builder.uninterpreted_option.add(UninterpretedOption.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public MessageOptions redact(MessageOptions value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.uninterpreted_option, UninterpretedOption.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/MethodDescriptorProto.java b/app/src/main/java/com/google/protobuf/MethodDescriptorProto.java
new file mode 100644
index 0000000..92033d7
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/MethodDescriptorProto.java
@@ -0,0 +1,296 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+
+import okio.ByteString;
+
+/**
+ * Describes a method of a service.
+ */
+public final class MethodDescriptorProto extends Message<MethodDescriptorProto, MethodDescriptorProto.Builder> {
+    public static final ProtoAdapter<MethodDescriptorProto> ADAPTER = new ProtoAdapter_MethodDescriptorProto();
+    public static final String DEFAULT_NAME = "";
+    public static final String DEFAULT_INPUT_TYPE = "";
+    public static final String DEFAULT_OUTPUT_TYPE = "";
+    public static final Boolean DEFAULT_CLIENT_STREAMING = false;
+    public static final Boolean DEFAULT_SERVER_STREAMING = false;
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String name;
+
+    /**
+     * Input and output type names.  These are resolved in the same way as
+     * FieldDescriptorProto.type_name, but must refer to a message type.
+     */
+    @WireField(
+            tag = 2,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String input_type;
+
+    @WireField(
+            tag = 3,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String output_type;
+
+    @WireField(
+            tag = 4,
+            adapter = "com.google.protobuf.MethodOptions#ADAPTER"
+    )
+    public final MethodOptions options;
+
+    /**
+     * Identifies if client streams multiple client messages
+     */
+    @WireField(
+            tag = 5,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean client_streaming;
+
+    /**
+     * Identifies if server streams multiple server messages
+     */
+    @WireField(
+            tag = 6,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean server_streaming;
+
+    public MethodDescriptorProto(String name, String input_type, String output_type,
+                                 MethodOptions options, Boolean client_streaming, Boolean server_streaming) {
+        this(name, input_type, output_type, options, client_streaming, server_streaming, ByteString.EMPTY);
+    }
+
+    public MethodDescriptorProto(String name, String input_type, String output_type,
+                                 MethodOptions options, Boolean client_streaming, Boolean server_streaming,
+                                 ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = name;
+        this.input_type = input_type;
+        this.output_type = output_type;
+        this.options = options;
+        this.client_streaming = client_streaming;
+        this.server_streaming = server_streaming;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = name;
+        builder.input_type = input_type;
+        builder.output_type = output_type;
+        builder.options = options;
+        builder.client_streaming = client_streaming;
+        builder.server_streaming = server_streaming;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof MethodDescriptorProto)) {
+            return false;
+        }
+        MethodDescriptorProto o = (MethodDescriptorProto) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(name, o.name)
+                && Internal.equals(input_type, o.input_type)
+                && Internal.equals(output_type, o.output_type)
+                && Internal.equals(options, o.options)
+                && Internal.equals(client_streaming, o.client_streaming)
+                && Internal.equals(server_streaming, o.server_streaming);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (name != null ? name.hashCode() : 0);
+            result = result * 37 + (input_type != null ? input_type.hashCode() : 0);
+            result = result * 37 + (output_type != null ? output_type.hashCode() : 0);
+            result = result * 37 + (options != null ? options.hashCode() : 0);
+            result = result * 37 + (client_streaming != null ? client_streaming.hashCode() : 0);
+            result = result * 37 + (server_streaming != null ? server_streaming.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (name != null) {
+            builder.append(", name=").append(name);
+        }
+        if (input_type != null) {
+            builder.append(", input_type=").append(input_type);
+        }
+        if (output_type != null) {
+            builder.append(", output_type=").append(output_type);
+        }
+        if (options != null) {
+            builder.append(", options=").append(options);
+        }
+        if (client_streaming != null) {
+            builder.append(", client_streaming=").append(client_streaming);
+        }
+        if (server_streaming != null) {
+            builder.append(", server_streaming=").append(server_streaming);
+        }
+        return builder.replace(0, 2, "MethodDescriptorProto{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<MethodDescriptorProto, Builder> {
+        public String name;
+
+        public String input_type;
+
+        public String output_type;
+
+        public MethodOptions options;
+
+        public Boolean client_streaming;
+
+        public Boolean server_streaming;
+
+        public Builder() {
+        }
+
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        /**
+         * Input and output type names.  These are resolved in the same way as
+         * FieldDescriptorProto.type_name, but must refer to a message type.
+         */
+        public Builder input_type(String input_type) {
+            this.input_type = input_type;
+            return this;
+        }
+
+        public Builder output_type(String output_type) {
+            this.output_type = output_type;
+            return this;
+        }
+
+        public Builder options(MethodOptions options) {
+            this.options = options;
+            return this;
+        }
+
+        /**
+         * Identifies if client streams multiple client messages
+         */
+        public Builder client_streaming(Boolean client_streaming) {
+            this.client_streaming = client_streaming;
+            return this;
+        }
+
+        /**
+         * Identifies if server streams multiple server messages
+         */
+        public Builder server_streaming(Boolean server_streaming) {
+            this.server_streaming = server_streaming;
+            return this;
+        }
+
+        @Override
+        public MethodDescriptorProto build() {
+            return new MethodDescriptorProto(name, input_type, output_type, options, client_streaming, server_streaming, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_MethodDescriptorProto extends ProtoAdapter<MethodDescriptorProto> {
+        public ProtoAdapter_MethodDescriptorProto() {
+            super(FieldEncoding.LENGTH_DELIMITED, MethodDescriptorProto.class);
+        }
+
+        @Override
+        public int encodedSize(MethodDescriptorProto value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(2, value.input_type)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(3, value.output_type)
+                    + MethodOptions.ADAPTER.encodedSizeWithTag(4, value.options)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(5, value.client_streaming)
+                    + ProtoAdapter.BOOL.encodedSizeWithTag(6, value.server_streaming)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, MethodDescriptorProto value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name);
+            ProtoAdapter.STRING.encodeWithTag(writer, 2, value.input_type);
+            ProtoAdapter.STRING.encodeWithTag(writer, 3, value.output_type);
+            MethodOptions.ADAPTER.encodeWithTag(writer, 4, value.options);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 5, value.client_streaming);
+            ProtoAdapter.BOOL.encodeWithTag(writer, 6, value.server_streaming);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public MethodDescriptorProto decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 2:
+                        builder.input_type(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 3:
+                        builder.output_type(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 4:
+                        builder.options(MethodOptions.ADAPTER.decode(reader));
+                        break;
+                    case 5:
+                        builder.client_streaming(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 6:
+                        builder.server_streaming(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public MethodDescriptorProto redact(MethodDescriptorProto value) {
+            Builder builder = value.newBuilder();
+            if (builder.options != null) {
+                builder.options = MethodOptions.ADAPTER.redact(builder.options);
+            }
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/MethodOptions.java b/app/src/main/java/com/google/protobuf/MethodOptions.java
new file mode 100644
index 0000000..1fa7990
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/MethodOptions.java
@@ -0,0 +1,195 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+public final class MethodOptions extends Message<MethodOptions, MethodOptions.Builder> {
+    public static final ProtoAdapter<MethodOptions> ADAPTER = new ProtoAdapter_MethodOptions();
+    public static final Boolean DEFAULT_DEPRECATED = false;
+    private static final long serialVersionUID = 0L;
+    /**
+     * Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+     * framework.  We apologize for hoarding these numbers to ourselves, but
+     * we were already using them long before we decided to release Protocol
+     * Buffers.
+     * Is this method deprecated?
+     * Depending on the target platform, this can emit Deprecated annotations
+     * for the method, or it will be completely ignored; in the very least,
+     * this is a formalization for deprecating methods.
+     */
+    @WireField(
+            tag = 33,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean deprecated;
+
+    /**
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    @WireField(
+            tag = 999,
+            adapter = "com.google.protobuf.UninterpretedOption#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<UninterpretedOption> uninterpreted_option;
+
+    public MethodOptions(Boolean deprecated, List<UninterpretedOption> uninterpreted_option) {
+        this(deprecated, uninterpreted_option, ByteString.EMPTY);
+    }
+
+    public MethodOptions(Boolean deprecated, List<UninterpretedOption> uninterpreted_option,
+                         ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.deprecated = deprecated;
+        this.uninterpreted_option = Internal.immutableCopyOf("uninterpreted_option", uninterpreted_option);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.deprecated = deprecated;
+        builder.uninterpreted_option = Internal.copyOf("uninterpreted_option", uninterpreted_option);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof MethodOptions)) {
+            return false;
+        }
+        MethodOptions o = (MethodOptions) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(deprecated, o.deprecated)
+                && uninterpreted_option.equals(o.uninterpreted_option);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (deprecated != null ? deprecated.hashCode() : 0);
+            result = result * 37 + uninterpreted_option.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (deprecated != null) {
+            builder.append(", deprecated=").append(deprecated);
+        }
+        if (!uninterpreted_option.isEmpty()) {
+            builder.append(", uninterpreted_option=").append(uninterpreted_option);
+        }
+        return builder.replace(0, 2, "MethodOptions{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<MethodOptions, Builder> {
+        public Boolean deprecated;
+
+        public List<UninterpretedOption> uninterpreted_option;
+
+        public Builder() {
+            uninterpreted_option = Internal.newMutableList();
+        }
+
+        /**
+         * Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+         * framework.  We apologize for hoarding these numbers to ourselves, but
+         * we were already using them long before we decided to release Protocol
+         * Buffers.
+         * Is this method deprecated?
+         * Depending on the target platform, this can emit Deprecated annotations
+         * for the method, or it will be completely ignored; in the very least,
+         * this is a formalization for deprecating methods.
+         */
+        public Builder deprecated(Boolean deprecated) {
+            this.deprecated = deprecated;
+            return this;
+        }
+
+        /**
+         * The parser stores options it doesn't recognize here. See above.
+         */
+        public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+            Internal.checkElementsNotNull(uninterpreted_option);
+            this.uninterpreted_option = uninterpreted_option;
+            return this;
+        }
+
+        @Override
+        public MethodOptions build() {
+            return new MethodOptions(deprecated, uninterpreted_option, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_MethodOptions extends ProtoAdapter<MethodOptions> {
+        public ProtoAdapter_MethodOptions() {
+            super(FieldEncoding.LENGTH_DELIMITED, MethodOptions.class);
+        }
+
+        @Override
+        public int encodedSize(MethodOptions value) {
+            return ProtoAdapter.BOOL.encodedSizeWithTag(33, value.deprecated)
+                    + UninterpretedOption.ADAPTER.asRepeated().encodedSizeWithTag(999, value.uninterpreted_option)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, MethodOptions value) throws IOException {
+            ProtoAdapter.BOOL.encodeWithTag(writer, 33, value.deprecated);
+            UninterpretedOption.ADAPTER.asRepeated().encodeWithTag(writer, 999, value.uninterpreted_option);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public MethodOptions decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 33:
+                        builder.deprecated(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 999:
+                        builder.uninterpreted_option.add(UninterpretedOption.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public MethodOptions redact(MethodOptions value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.uninterpreted_option, UninterpretedOption.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/OneofDescriptorProto.java b/app/src/main/java/com/google/protobuf/OneofDescriptorProto.java
new file mode 100644
index 0000000..841f576
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/OneofDescriptorProto.java
@@ -0,0 +1,141 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+
+import okio.ByteString;
+
+/**
+ * Describes a oneof.
+ */
+public final class OneofDescriptorProto extends Message<OneofDescriptorProto, OneofDescriptorProto.Builder> {
+    public static final ProtoAdapter<OneofDescriptorProto> ADAPTER = new ProtoAdapter_OneofDescriptorProto();
+    public static final String DEFAULT_NAME = "";
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String name;
+
+    public OneofDescriptorProto(String name) {
+        this(name, ByteString.EMPTY);
+    }
+
+    public OneofDescriptorProto(String name, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = name;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = name;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof OneofDescriptorProto)) {
+            return false;
+        }
+        OneofDescriptorProto o = (OneofDescriptorProto) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(name, o.name);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (name != null ? name.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (name != null) {
+            builder.append(", name=").append(name);
+        }
+        return builder.replace(0, 2, "OneofDescriptorProto{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<OneofDescriptorProto, Builder> {
+        public String name;
+
+        public Builder() {
+        }
+
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        @Override
+        public OneofDescriptorProto build() {
+            return new OneofDescriptorProto(name, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_OneofDescriptorProto extends ProtoAdapter<OneofDescriptorProto> {
+        public ProtoAdapter_OneofDescriptorProto() {
+            super(FieldEncoding.LENGTH_DELIMITED, OneofDescriptorProto.class);
+        }
+
+        @Override
+        public int encodedSize(OneofDescriptorProto value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, OneofDescriptorProto value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public OneofDescriptorProto decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public OneofDescriptorProto redact(OneofDescriptorProto value) {
+            Builder builder = value.newBuilder();
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/ServiceDescriptorProto.java b/app/src/main/java/com/google/protobuf/ServiceDescriptorProto.java
new file mode 100644
index 0000000..dd7a07d
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/ServiceDescriptorProto.java
@@ -0,0 +1,201 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+/**
+ * Describes a service.
+ */
+public final class ServiceDescriptorProto extends Message<ServiceDescriptorProto, ServiceDescriptorProto.Builder> {
+    public static final ProtoAdapter<ServiceDescriptorProto> ADAPTER = new ProtoAdapter_ServiceDescriptorProto();
+    public static final String DEFAULT_NAME = "";
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String name;
+
+    @WireField(
+            tag = 2,
+            adapter = "com.google.protobuf.MethodDescriptorProto#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<MethodDescriptorProto> method;
+
+    @WireField(
+            tag = 3,
+            adapter = "com.google.protobuf.ServiceOptions#ADAPTER"
+    )
+    public final ServiceOptions options;
+
+    public ServiceDescriptorProto(String name, List<MethodDescriptorProto> method,
+                                  ServiceOptions options) {
+        this(name, method, options, ByteString.EMPTY);
+    }
+
+    public ServiceDescriptorProto(String name, List<MethodDescriptorProto> method,
+                                  ServiceOptions options, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = name;
+        this.method = Internal.immutableCopyOf("method", method);
+        this.options = options;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = name;
+        builder.method = Internal.copyOf("method", method);
+        builder.options = options;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof ServiceDescriptorProto)) {
+            return false;
+        }
+        ServiceDescriptorProto o = (ServiceDescriptorProto) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(name, o.name)
+                && method.equals(o.method)
+                && Internal.equals(options, o.options);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (name != null ? name.hashCode() : 0);
+            result = result * 37 + method.hashCode();
+            result = result * 37 + (options != null ? options.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (name != null) {
+            builder.append(", name=").append(name);
+        }
+        if (!method.isEmpty()) {
+            builder.append(", method=").append(method);
+        }
+        if (options != null) {
+            builder.append(", options=").append(options);
+        }
+        return builder.replace(0, 2, "ServiceDescriptorProto{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<ServiceDescriptorProto, Builder> {
+        public String name;
+
+        public List<MethodDescriptorProto> method;
+
+        public ServiceOptions options;
+
+        public Builder() {
+            method = Internal.newMutableList();
+        }
+
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        public Builder method(List<MethodDescriptorProto> method) {
+            Internal.checkElementsNotNull(method);
+            this.method = method;
+            return this;
+        }
+
+        public Builder options(ServiceOptions options) {
+            this.options = options;
+            return this;
+        }
+
+        @Override
+        public ServiceDescriptorProto build() {
+            return new ServiceDescriptorProto(name, method, options, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_ServiceDescriptorProto extends ProtoAdapter<ServiceDescriptorProto> {
+        public ProtoAdapter_ServiceDescriptorProto() {
+            super(FieldEncoding.LENGTH_DELIMITED, ServiceDescriptorProto.class);
+        }
+
+        @Override
+        public int encodedSize(ServiceDescriptorProto value) {
+            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)
+                    + MethodDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(2, value.method)
+                    + ServiceOptions.ADAPTER.encodedSizeWithTag(3, value.options)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, ServiceDescriptorProto value) throws IOException {
+            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name);
+            MethodDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 2, value.method);
+            ServiceOptions.ADAPTER.encodeWithTag(writer, 3, value.options);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public ServiceDescriptorProto decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.name(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 2:
+                        builder.method.add(MethodDescriptorProto.ADAPTER.decode(reader));
+                        break;
+                    case 3:
+                        builder.options(ServiceOptions.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public ServiceDescriptorProto redact(ServiceDescriptorProto value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.method, MethodDescriptorProto.ADAPTER);
+            if (builder.options != null) {
+                builder.options = ServiceOptions.ADAPTER.redact(builder.options);
+            }
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/ServiceOptions.java b/app/src/main/java/com/google/protobuf/ServiceOptions.java
new file mode 100644
index 0000000..f1703fb
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/ServiceOptions.java
@@ -0,0 +1,195 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+public final class ServiceOptions extends Message<ServiceOptions, ServiceOptions.Builder> {
+    public static final ProtoAdapter<ServiceOptions> ADAPTER = new ProtoAdapter_ServiceOptions();
+    public static final Boolean DEFAULT_DEPRECATED = false;
+    private static final long serialVersionUID = 0L;
+    /**
+     * Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+     * framework.  We apologize for hoarding these numbers to ourselves, but
+     * we were already using them long before we decided to release Protocol
+     * Buffers.
+     * Is this service deprecated?
+     * Depending on the target platform, this can emit Deprecated annotations
+     * for the service, or it will be completely ignored; in the very least,
+     * this is a formalization for deprecating services.
+     */
+    @WireField(
+            tag = 33,
+            adapter = "com.squareup.wire.ProtoAdapter#BOOL"
+    )
+    public final Boolean deprecated;
+
+    /**
+     * The parser stores options it doesn't recognize here. See above.
+     */
+    @WireField(
+            tag = 999,
+            adapter = "com.google.protobuf.UninterpretedOption#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<UninterpretedOption> uninterpreted_option;
+
+    public ServiceOptions(Boolean deprecated, List<UninterpretedOption> uninterpreted_option) {
+        this(deprecated, uninterpreted_option, ByteString.EMPTY);
+    }
+
+    public ServiceOptions(Boolean deprecated, List<UninterpretedOption> uninterpreted_option,
+                          ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.deprecated = deprecated;
+        this.uninterpreted_option = Internal.immutableCopyOf("uninterpreted_option", uninterpreted_option);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.deprecated = deprecated;
+        builder.uninterpreted_option = Internal.copyOf("uninterpreted_option", uninterpreted_option);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof ServiceOptions)) {
+            return false;
+        }
+        ServiceOptions o = (ServiceOptions) other;
+        return unknownFields().equals(o.unknownFields())
+                && Internal.equals(deprecated, o.deprecated)
+                && uninterpreted_option.equals(o.uninterpreted_option);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (deprecated != null ? deprecated.hashCode() : 0);
+            result = result * 37 + uninterpreted_option.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (deprecated != null) {
+            builder.append(", deprecated=").append(deprecated);
+        }
+        if (!uninterpreted_option.isEmpty()) {
+            builder.append(", uninterpreted_option=").append(uninterpreted_option);
+        }
+        return builder.replace(0, 2, "ServiceOptions{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<ServiceOptions, Builder> {
+        public Boolean deprecated;
+
+        public List<UninterpretedOption> uninterpreted_option;
+
+        public Builder() {
+            uninterpreted_option = Internal.newMutableList();
+        }
+
+        /**
+         * Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+         * framework.  We apologize for hoarding these numbers to ourselves, but
+         * we were already using them long before we decided to release Protocol
+         * Buffers.
+         * Is this service deprecated?
+         * Depending on the target platform, this can emit Deprecated annotations
+         * for the service, or it will be completely ignored; in the very least,
+         * this is a formalization for deprecating services.
+         */
+        public Builder deprecated(Boolean deprecated) {
+            this.deprecated = deprecated;
+            return this;
+        }
+
+        /**
+         * The parser stores options it doesn't recognize here. See above.
+         */
+        public Builder uninterpreted_option(List<UninterpretedOption> uninterpreted_option) {
+            Internal.checkElementsNotNull(uninterpreted_option);
+            this.uninterpreted_option = uninterpreted_option;
+            return this;
+        }
+
+        @Override
+        public ServiceOptions build() {
+            return new ServiceOptions(deprecated, uninterpreted_option, super.buildUnknownFields());
+        }
+    }
+
+    private static final class ProtoAdapter_ServiceOptions extends ProtoAdapter<ServiceOptions> {
+        public ProtoAdapter_ServiceOptions() {
+            super(FieldEncoding.LENGTH_DELIMITED, ServiceOptions.class);
+        }
+
+        @Override
+        public int encodedSize(ServiceOptions value) {
+            return ProtoAdapter.BOOL.encodedSizeWithTag(33, value.deprecated)
+                    + UninterpretedOption.ADAPTER.asRepeated().encodedSizeWithTag(999, value.uninterpreted_option)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, ServiceOptions value) throws IOException {
+            ProtoAdapter.BOOL.encodeWithTag(writer, 33, value.deprecated);
+            UninterpretedOption.ADAPTER.asRepeated().encodeWithTag(writer, 999, value.uninterpreted_option);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public ServiceOptions decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 33:
+                        builder.deprecated(ProtoAdapter.BOOL.decode(reader));
+                        break;
+                    case 999:
+                        builder.uninterpreted_option.add(UninterpretedOption.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public ServiceOptions redact(ServiceOptions value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.uninterpreted_option, UninterpretedOption.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/SourceCodeInfo.java b/app/src/main/java/com/google/protobuf/SourceCodeInfo.java
new file mode 100644
index 0000000..f700926
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/SourceCodeInfo.java
@@ -0,0 +1,638 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+/**
+ * ===================================================================
+ * Optional source code info
+ * Encapsulates information about the original source file from which a
+ * FileDescriptorProto was generated.
+ */
+public final class SourceCodeInfo extends Message<SourceCodeInfo, SourceCodeInfo.Builder> {
+    public static final ProtoAdapter<SourceCodeInfo> ADAPTER = new ProtoAdapter_SourceCodeInfo();
+
+    private static final long serialVersionUID = 0L;
+
+    /**
+     * A Location identifies a piece of source code in a .proto file which
+     * corresponds to a particular definition.  This information is intended
+     * to be useful to IDEs, code indexers, documentation generators, and similar
+     * tools.
+     * <p>
+     * For example, say we have a file like:
+     * message Foo {
+     * optional string foo = 1;
+     * }
+     * Let's look at just the field definition:
+     * optional string foo = 1;
+     * ^       ^^     ^^  ^  ^^^
+     * a       bc     de  f  ghi
+     * We have the following locations:
+     * span   path               represents
+     * [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
+     * [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
+     * [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
+     * [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
+     * [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
+     * <p>
+     * Notes:
+     * - A location may refer to a repeated field itself (i.e. not to any
+     * particular index within it).  This is used whenever a set of elements are
+     * logically enclosed in a single code segment.  For example, an entire
+     * extend block (possibly containing multiple extension definitions) will
+     * have an outer location whose path refers to the "extensions" repeated
+     * field without an index.
+     * - Multiple locations may have the same path.  This happens when a single
+     * logical declaration is spread out across multiple places.  The most
+     * obvious example is the "extend" block again -- there may be multiple
+     * extend blocks in the same scope, each of which will have the same path.
+     * - A location's span is not always a subset of its parent's span.  For
+     * example, the "extendee" of an extension declaration appears at the
+     * beginning of the "extend" block and is shared by all extensions within
+     * the block.
+     * - Just because a location's span is a subset of some other location's span
+     * does not mean that it is a descendent.  For example, a "group" defines
+     * both a type and a field in a single declaration.  Thus, the locations
+     * corresponding to the type and field and their components will overlap.
+     * - Code which tries to interpret locations should probably be designed to
+     * ignore those that it doesn't understand, as more types of locations could
+     * be recorded in the future.
+     */
+    @WireField(
+            tag = 1,
+            adapter = "com.google.protobuf.SourceCodeInfo$Location#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<Location> location;
+
+    public SourceCodeInfo(List<Location> location) {
+        this(location, ByteString.EMPTY);
+    }
+
+    public SourceCodeInfo(List<Location> location, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.location = Internal.immutableCopyOf("location", location);
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.location = Internal.copyOf("location", location);
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof SourceCodeInfo)) {
+            return false;
+        }
+        SourceCodeInfo o = (SourceCodeInfo) other;
+        return unknownFields().equals(o.unknownFields())
+                && location.equals(o.location);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + location.hashCode();
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (!location.isEmpty()) {
+            builder.append(", location=").append(location);
+        }
+        return builder.replace(0, 2, "SourceCodeInfo{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<SourceCodeInfo, Builder> {
+        public List<Location> location;
+
+        public Builder() {
+            location = Internal.newMutableList();
+        }
+
+        /**
+         * A Location identifies a piece of source code in a .proto file which
+         * corresponds to a particular definition.  This information is intended
+         * to be useful to IDEs, code indexers, documentation generators, and similar
+         * tools.
+         * <p>
+         * For example, say we have a file like:
+         * message Foo {
+         * optional string foo = 1;
+         * }
+         * Let's look at just the field definition:
+         * optional string foo = 1;
+         * ^       ^^     ^^  ^  ^^^
+         * a       bc     de  f  ghi
+         * We have the following locations:
+         * span   path               represents
+         * [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
+         * [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
+         * [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
+         * [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
+         * [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
+         * <p>
+         * Notes:
+         * - A location may refer to a repeated field itself (i.e. not to any
+         * particular index within it).  This is used whenever a set of elements are
+         * logically enclosed in a single code segment.  For example, an entire
+         * extend block (possibly containing multiple extension definitions) will
+         * have an outer location whose path refers to the "extensions" repeated
+         * field without an index.
+         * - Multiple locations may have the same path.  This happens when a single
+         * logical declaration is spread out across multiple places.  The most
+         * obvious example is the "extend" block again -- there may be multiple
+         * extend blocks in the same scope, each of which will have the same path.
+         * - A location's span is not always a subset of its parent's span.  For
+         * example, the "extendee" of an extension declaration appears at the
+         * beginning of the "extend" block and is shared by all extensions within
+         * the block.
+         * - Just because a location's span is a subset of some other location's span
+         * does not mean that it is a descendent.  For example, a "group" defines
+         * both a type and a field in a single declaration.  Thus, the locations
+         * corresponding to the type and field and their components will overlap.
+         * - Code which tries to interpret locations should probably be designed to
+         * ignore those that it doesn't understand, as more types of locations could
+         * be recorded in the future.
+         */
+        public Builder location(List<Location> location) {
+            Internal.checkElementsNotNull(location);
+            this.location = location;
+            return this;
+        }
+
+        @Override
+        public SourceCodeInfo build() {
+            return new SourceCodeInfo(location, super.buildUnknownFields());
+        }
+    }
+
+    public static final class Location extends Message<Location, Location.Builder> {
+        public static final ProtoAdapter<Location> ADAPTER = new ProtoAdapter_Location();
+        public static final String DEFAULT_LEADING_COMMENTS = "";
+        public static final String DEFAULT_TRAILING_COMMENTS = "";
+        private static final long serialVersionUID = 0L;
+        /**
+         * Identifies which part of the FileDescriptorProto was defined at this
+         * location.
+         * <p>
+         * Each element is a field number or an index.  They form a path from
+         * the root FileDescriptorProto to the place where the definition.  For
+         * example, this path:
+         * [ 4, 3, 2, 7, 1 ]
+         * refers to:
+         * file.message_type(3)  // 4, 3
+         * .field(7)         // 2, 7
+         * .name()           // 1
+         * This is because FileDescriptorProto.message_type has field number 4:
+         * repeated DescriptorProto message_type = 4;
+         * and DescriptorProto.field has field number 2:
+         * repeated FieldDescriptorProto field = 2;
+         * and FieldDescriptorProto.name has field number 1:
+         * optional string name = 1;
+         * <p>
+         * Thus, the above path gives the location of a field name.  If we removed
+         * the last element:
+         * [ 4, 3, 2, 7 ]
+         * this path refers to the whole field declaration (from the beginning
+         * of the label to the terminating semicolon).
+         */
+        @WireField(
+                tag = 1,
+                adapter = "com.squareup.wire.ProtoAdapter#INT32",
+                label = WireField.Label.PACKED
+        )
+        public final List<Integer> path;
+
+        /**
+         * Always has exactly three or four elements: start line, start column,
+         * end line (optional, otherwise assumed same as start line), end column.
+         * These are packed into a single field for efficiency.  Note that line
+         * and column numbers are zero-based -- typically you will want to add
+         * 1 to each before displaying to a user.
+         */
+        @WireField(
+                tag = 2,
+                adapter = "com.squareup.wire.ProtoAdapter#INT32",
+                label = WireField.Label.PACKED
+        )
+        public final List<Integer> span;
+
+        /**
+         * If this SourceCodeInfo represents a complete declaration, these are any
+         * comments appearing before and after the declaration which appear to be
+         * attached to the declaration.
+         * <p>
+         * A series of line comments appearing on consecutive lines, with no other
+         * tokens appearing on those lines, will be treated as a single comment.
+         * <p>
+         * leading_detached_comments will keep paragraphs of comments that appear
+         * before (but not connected to) the current element. Each paragraph,
+         * separated by empty lines, will be one comment element in the repeated
+         * field.
+         * <p>
+         * Only the comment content is provided; comment markers (e.g. //) are
+         * stripped out.  For block comments, leading whitespace and an asterisk
+         * will be stripped from the beginning of each line other than the first.
+         * Newlines are included in the output.
+         * <p>
+         * Examples:
+         * <p>
+         * optional int32 foo = 1;  // Comment attached to foo.
+         * // Comment attached to bar.
+         * optional int32 bar = 2;
+         * <p>
+         * optional string baz = 3;
+         * // Comment attached to baz.
+         * // Another line attached to baz.
+         * <p>
+         * // Comment attached to qux.
+         * //
+         * // Another line attached to qux.
+         * optional double qux = 4;
+         * <p>
+         * // Detached comment for corge. This is not leading or trailing comments
+         * // to qux or corge because there are blank lines separating it from
+         * // both.
+         * <p>
+         * // Detached comment for corge paragraph 2.
+         * <p>
+         * optional string corge = 5;
+         * /* Block comment attached
+         * * to corge.  Leading asterisks
+         * * will be removed. &#42;/
+         * /* Block comment attached to
+         * * grault. &#42;/
+         * optional int32 grault = 6;
+         * <p>
+         * // ignored detached comments.
+         */
+        @WireField(
+                tag = 3,
+                adapter = "com.squareup.wire.ProtoAdapter#STRING"
+        )
+        public final String leading_comments;
+
+        @WireField(
+                tag = 4,
+                adapter = "com.squareup.wire.ProtoAdapter#STRING"
+        )
+        public final String trailing_comments;
+
+        @WireField(
+                tag = 6,
+                adapter = "com.squareup.wire.ProtoAdapter#STRING",
+                label = WireField.Label.REPEATED
+        )
+        public final List<String> leading_detached_comments;
+
+        public Location(List<Integer> path, List<Integer> span, String leading_comments,
+                        String trailing_comments, List<String> leading_detached_comments) {
+            this(path, span, leading_comments, trailing_comments, leading_detached_comments, ByteString.EMPTY);
+        }
+
+        public Location(List<Integer> path, List<Integer> span, String leading_comments,
+                        String trailing_comments, List<String> leading_detached_comments,
+                        ByteString unknownFields) {
+            super(ADAPTER, unknownFields);
+            this.path = Internal.immutableCopyOf("path", path);
+            this.span = Internal.immutableCopyOf("span", span);
+            this.leading_comments = leading_comments;
+            this.trailing_comments = trailing_comments;
+            this.leading_detached_comments = Internal.immutableCopyOf("leading_detached_comments", leading_detached_comments);
+        }
+
+        @Override
+        public Builder newBuilder() {
+            Builder builder = new Builder();
+            builder.path = Internal.copyOf("path", path);
+            builder.span = Internal.copyOf("span", span);
+            builder.leading_comments = leading_comments;
+            builder.trailing_comments = trailing_comments;
+            builder.leading_detached_comments = Internal.copyOf("leading_detached_comments", leading_detached_comments);
+            builder.addUnknownFields(unknownFields());
+            return builder;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if (other == this) {
+                return true;
+            }
+            if (!(other instanceof Location)) {
+                return false;
+            }
+            Location o = (Location) other;
+            return unknownFields().equals(o.unknownFields())
+                    && path.equals(o.path)
+                    && span.equals(o.span)
+                    && Internal.equals(leading_comments, o.leading_comments)
+                    && Internal.equals(trailing_comments, o.trailing_comments)
+                    && leading_detached_comments.equals(o.leading_detached_comments);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = super.hashCode;
+            if (result == 0) {
+                result = unknownFields().hashCode();
+                result = result * 37 + path.hashCode();
+                result = result * 37 + span.hashCode();
+                result = result * 37 + (leading_comments != null ? leading_comments.hashCode() : 0);
+                result = result * 37 + (trailing_comments != null ? trailing_comments.hashCode() : 0);
+                result = result * 37 + leading_detached_comments.hashCode();
+                super.hashCode = result;
+            }
+            return result;
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder builder = new StringBuilder();
+            if (!path.isEmpty()) {
+                builder.append(", path=").append(path);
+            }
+            if (!span.isEmpty()) {
+                builder.append(", span=").append(span);
+            }
+            if (leading_comments != null) {
+                builder.append(", leading_comments=").append(leading_comments);
+            }
+            if (trailing_comments != null) {
+                builder.append(", trailing_comments=").append(trailing_comments);
+            }
+            if (!leading_detached_comments.isEmpty()) {
+                builder.append(", leading_detached_comments=").append(leading_detached_comments);
+            }
+            return builder.replace(0, 2, "Location{").append('}').toString();
+        }
+
+        public static final class Builder extends Message.Builder<Location, Builder> {
+            public List<Integer> path;
+
+            public List<Integer> span;
+
+            public String leading_comments;
+
+            public String trailing_comments;
+
+            public List<String> leading_detached_comments;
+
+            public Builder() {
+                path = Internal.newMutableList();
+                span = Internal.newMutableList();
+                leading_detached_comments = Internal.newMutableList();
+            }
+
+            /**
+             * Identifies which part of the FileDescriptorProto was defined at this
+             * location.
+             * <p>
+             * Each element is a field number or an index.  They form a path from
+             * the root FileDescriptorProto to the place where the definition.  For
+             * example, this path:
+             * [ 4, 3, 2, 7, 1 ]
+             * refers to:
+             * file.message_type(3)  // 4, 3
+             * .field(7)         // 2, 7
+             * .name()           // 1
+             * This is because FileDescriptorProto.message_type has field number 4:
+             * repeated DescriptorProto message_type = 4;
+             * and DescriptorProto.field has field number 2:
+             * repeated FieldDescriptorProto field = 2;
+             * and FieldDescriptorProto.name has field number 1:
+             * optional string name = 1;
+             * <p>
+             * Thus, the above path gives the location of a field name.  If we removed
+             * the last element:
+             * [ 4, 3, 2, 7 ]
+             * this path refers to the whole field declaration (from the beginning
+             * of the label to the terminating semicolon).
+             */
+            public Builder path(List<Integer> path) {
+                Internal.checkElementsNotNull(path);
+                this.path = path;
+                return this;
+            }
+
+            /**
+             * Always has exactly three or four elements: start line, start column,
+             * end line (optional, otherwise assumed same as start line), end column.
+             * These are packed into a single field for efficiency.  Note that line
+             * and column numbers are zero-based -- typically you will want to add
+             * 1 to each before displaying to a user.
+             */
+            public Builder span(List<Integer> span) {
+                Internal.checkElementsNotNull(span);
+                this.span = span;
+                return this;
+            }
+
+            /**
+             * If this SourceCodeInfo represents a complete declaration, these are any
+             * comments appearing before and after the declaration which appear to be
+             * attached to the declaration.
+             * <p>
+             * A series of line comments appearing on consecutive lines, with no other
+             * tokens appearing on those lines, will be treated as a single comment.
+             * <p>
+             * leading_detached_comments will keep paragraphs of comments that appear
+             * before (but not connected to) the current element. Each paragraph,
+             * separated by empty lines, will be one comment element in the repeated
+             * field.
+             * <p>
+             * Only the comment content is provided; comment markers (e.g. //) are
+             * stripped out.  For block comments, leading whitespace and an asterisk
+             * will be stripped from the beginning of each line other than the first.
+             * Newlines are included in the output.
+             * <p>
+             * Examples:
+             * <p>
+             * optional int32 foo = 1;  // Comment attached to foo.
+             * // Comment attached to bar.
+             * optional int32 bar = 2;
+             * <p>
+             * optional string baz = 3;
+             * // Comment attached to baz.
+             * // Another line attached to baz.
+             * <p>
+             * // Comment attached to qux.
+             * //
+             * // Another line attached to qux.
+             * optional double qux = 4;
+             * <p>
+             * // Detached comment for corge. This is not leading or trailing comments
+             * // to qux or corge because there are blank lines separating it from
+             * // both.
+             * <p>
+             * // Detached comment for corge paragraph 2.
+             * <p>
+             * optional string corge = 5;
+             * /* Block comment attached
+             * * to corge.  Leading asterisks
+             * * will be removed. &#42;/
+             * /* Block comment attached to
+             * * grault. &#42;/
+             * optional int32 grault = 6;
+             * <p>
+             * // ignored detached comments.
+             */
+            public Builder leading_comments(String leading_comments) {
+                this.leading_comments = leading_comments;
+                return this;
+            }
+
+            public Builder trailing_comments(String trailing_comments) {
+                this.trailing_comments = trailing_comments;
+                return this;
+            }
+
+            public Builder leading_detached_comments(List<String> leading_detached_comments) {
+                Internal.checkElementsNotNull(leading_detached_comments);
+                this.leading_detached_comments = leading_detached_comments;
+                return this;
+            }
+
+            @Override
+            public Location build() {
+                return new Location(path, span, leading_comments, trailing_comments, leading_detached_comments, super.buildUnknownFields());
+            }
+        }
+
+        private static final class ProtoAdapter_Location extends ProtoAdapter<Location> {
+            public ProtoAdapter_Location() {
+                super(FieldEncoding.LENGTH_DELIMITED, Location.class);
+            }
+
+            @Override
+            public int encodedSize(Location value) {
+                return ProtoAdapter.INT32.asPacked().encodedSizeWithTag(1, value.path)
+                        + ProtoAdapter.INT32.asPacked().encodedSizeWithTag(2, value.span)
+                        + ProtoAdapter.STRING.encodedSizeWithTag(3, value.leading_comments)
+                        + ProtoAdapter.STRING.encodedSizeWithTag(4, value.trailing_comments)
+                        + ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(6, value.leading_detached_comments)
+                        + value.unknownFields().size();
+            }
+
+            @Override
+            public void encode(ProtoWriter writer, Location value) throws IOException {
+                ProtoAdapter.INT32.asPacked().encodeWithTag(writer, 1, value.path);
+                ProtoAdapter.INT32.asPacked().encodeWithTag(writer, 2, value.span);
+                ProtoAdapter.STRING.encodeWithTag(writer, 3, value.leading_comments);
+                ProtoAdapter.STRING.encodeWithTag(writer, 4, value.trailing_comments);
+                ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 6, value.leading_detached_comments);
+                writer.writeBytes(value.unknownFields());
+            }
+
+            @Override
+            public Location decode(ProtoReader reader) throws IOException {
+                Builder builder = new Builder();
+                long token = reader.beginMessage();
+                for (int tag; (tag = reader.nextTag()) != -1; ) {
+                    switch (tag) {
+                        case 1:
+                            builder.path.add(ProtoAdapter.INT32.decode(reader));
+                            break;
+                        case 2:
+                            builder.span.add(ProtoAdapter.INT32.decode(reader));
+                            break;
+                        case 3:
+                            builder.leading_comments(ProtoAdapter.STRING.decode(reader));
+                            break;
+                        case 4:
+                            builder.trailing_comments(ProtoAdapter.STRING.decode(reader));
+                            break;
+                        case 6:
+                            builder.leading_detached_comments.add(ProtoAdapter.STRING.decode(reader));
+                            break;
+                        default: {
+                            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                            builder.addUnknownField(tag, fieldEncoding, value);
+                        }
+                    }
+                }
+                reader.endMessage(token);
+                return builder.build();
+            }
+
+            @Override
+            public Location redact(Location value) {
+                Builder builder = value.newBuilder();
+                builder.clearUnknownFields();
+                return builder.build();
+            }
+        }
+    }
+
+    private static final class ProtoAdapter_SourceCodeInfo extends ProtoAdapter<SourceCodeInfo> {
+        public ProtoAdapter_SourceCodeInfo() {
+            super(FieldEncoding.LENGTH_DELIMITED, SourceCodeInfo.class);
+        }
+
+        @Override
+        public int encodedSize(SourceCodeInfo value) {
+            return Location.ADAPTER.asRepeated().encodedSizeWithTag(1, value.location)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, SourceCodeInfo value) throws IOException {
+            Location.ADAPTER.asRepeated().encodeWithTag(writer, 1, value.location);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public SourceCodeInfo decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.location.add(Location.ADAPTER.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public SourceCodeInfo redact(SourceCodeInfo value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.location, Location.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/java/com/google/protobuf/UninterpretedOption.java b/app/src/main/java/com/google/protobuf/UninterpretedOption.java
new file mode 100644
index 0000000..b554cc0
--- /dev/null
+++ b/app/src/main/java/com/google/protobuf/UninterpretedOption.java
@@ -0,0 +1,477 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: google/protobuf/descriptor.proto
+package com.google.protobuf;
+
+import com.squareup.wire.FieldEncoding;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
+
+import java.io.IOException;
+import java.util.List;
+
+import okio.ByteString;
+
+/**
+ * A message representing a option the parser does not recognize. This only
+ * appears in options protos created by the compiler::Parser class.
+ * DescriptorPool resolves these when building Descriptor objects. Therefore,
+ * options protos in descriptor objects (e.g. returned by Descriptor::options(),
+ * or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
+ * in them.
+ */
+public final class UninterpretedOption extends Message<UninterpretedOption, UninterpretedOption.Builder> {
+    public static final ProtoAdapter<UninterpretedOption> ADAPTER = new ProtoAdapter_UninterpretedOption();
+    public static final String DEFAULT_IDENTIFIER_VALUE = "";
+    public static final Long DEFAULT_POSITIVE_INT_VALUE = 0L;
+    public static final Long DEFAULT_NEGATIVE_INT_VALUE = 0L;
+    public static final Double DEFAULT_DOUBLE_VALUE = 0.0d;
+    public static final ByteString DEFAULT_STRING_VALUE = ByteString.EMPTY;
+    public static final String DEFAULT_AGGREGATE_VALUE = "";
+    private static final long serialVersionUID = 0L;
+    @WireField(
+            tag = 2,
+            adapter = "com.google.protobuf.UninterpretedOption$NamePart#ADAPTER",
+            label = WireField.Label.REPEATED
+    )
+    public final List<NamePart> name;
+
+    /**
+     * The value of the uninterpreted option, in whatever type the tokenizer
+     * identified it as during parsing. Exactly one of these should be set.
+     */
+    @WireField(
+            tag = 3,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String identifier_value;
+
+    @WireField(
+            tag = 4,
+            adapter = "com.squareup.wire.ProtoAdapter#UINT64"
+    )
+    public final Long positive_int_value;
+
+    @WireField(
+            tag = 5,
+            adapter = "com.squareup.wire.ProtoAdapter#INT64"
+    )
+    public final Long negative_int_value;
+
+    @WireField(
+            tag = 6,
+            adapter = "com.squareup.wire.ProtoAdapter#DOUBLE"
+    )
+    public final Double double_value;
+
+    @WireField(
+            tag = 7,
+            adapter = "com.squareup.wire.ProtoAdapter#BYTES"
+    )
+    public final ByteString string_value;
+
+    @WireField(
+            tag = 8,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String aggregate_value;
+
+    public UninterpretedOption(List<NamePart> name, String identifier_value, Long positive_int_value,
+                               Long negative_int_value, Double double_value, ByteString string_value,
+                               String aggregate_value) {
+        this(name, identifier_value, positive_int_value, negative_int_value, double_value, string_value, aggregate_value, ByteString.EMPTY);
+    }
+
+    public UninterpretedOption(List<NamePart> name, String identifier_value, Long positive_int_value,
+                               Long negative_int_value, Double double_value, ByteString string_value, String aggregate_value,
+                               ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.name = Internal.immutableCopyOf("name", name);
+        this.identifier_value = identifier_value;
+        this.positive_int_value = positive_int_value;
+        this.negative_int_value = negative_int_value;
+        this.double_value = double_value;
+        this.string_value = string_value;
+        this.aggregate_value = aggregate_value;
+    }
+
+    @Override
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.name = Internal.copyOf("name", name);
+        builder.identifier_value = identifier_value;
+        builder.positive_int_value = positive_int_value;
+        builder.negative_int_value = negative_int_value;
+        builder.double_value = double_value;
+        builder.string_value = string_value;
+        builder.aggregate_value = aggregate_value;
+        builder.addUnknownFields(unknownFields());
+        return builder;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof UninterpretedOption)) {
+            return false;
+        }
+        UninterpretedOption o = (UninterpretedOption) other;
+        return unknownFields().equals(o.unknownFields())
+                && name.equals(o.name)
+                && Internal.equals(identifier_value, o.identifier_value)
+                && Internal.equals(positive_int_value, o.positive_int_value)
+                && Internal.equals(negative_int_value, o.negative_int_value)
+                && Internal.equals(double_value, o.double_value)
+                && Internal.equals(string_value, o.string_value)
+                && Internal.equals(aggregate_value, o.aggregate_value);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + name.hashCode();
+            result = result * 37 + (identifier_value != null ? identifier_value.hashCode() : 0);
+            result = result * 37 + (positive_int_value != null ? positive_int_value.hashCode() : 0);
+            result = result * 37 + (negative_int_value != null ? negative_int_value.hashCode() : 0);
+            result = result * 37 + (double_value != null ? double_value.hashCode() : 0);
+            result = result * 37 + (string_value != null ? string_value.hashCode() : 0);
+            result = result * 37 + (aggregate_value != null ? aggregate_value.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (!name.isEmpty()) {
+            builder.append(", name=").append(name);
+        }
+        if (identifier_value != null) {
+            builder.append(", identifier_value=").append(identifier_value);
+        }
+        if (positive_int_value != null) {
+            builder.append(", positive_int_value=").append(positive_int_value);
+        }
+        if (negative_int_value != null) {
+            builder.append(", negative_int_value=").append(negative_int_value);
+        }
+        if (double_value != null) {
+            builder.append(", double_value=").append(double_value);
+        }
+        if (string_value != null) {
+            builder.append(", string_value=").append(string_value);
+        }
+        if (aggregate_value != null) {
+            builder.append(", aggregate_value=").append(aggregate_value);
+        }
+        return builder.replace(0, 2, "UninterpretedOption{").append('}').toString();
+    }
+
+    public static final class Builder extends Message.Builder<UninterpretedOption, Builder> {
+        public List<NamePart> name;
+
+        public String identifier_value;
+
+        public Long positive_int_value;
+
+        public Long negative_int_value;
+
+        public Double double_value;
+
+        public ByteString string_value;
+
+        public String aggregate_value;
+
+        public Builder() {
+            name = Internal.newMutableList();
+        }
+
+        public Builder name(List<NamePart> name) {
+            Internal.checkElementsNotNull(name);
+            this.name = name;
+            return this;
+        }
+
+        /**
+         * The value of the uninterpreted option, in whatever type the tokenizer
+         * identified it as during parsing. Exactly one of these should be set.
+         */
+        public Builder identifier_value(String identifier_value) {
+            this.identifier_value = identifier_value;
+            return this;
+        }
+
+        public Builder positive_int_value(Long positive_int_value) {
+            this.positive_int_value = positive_int_value;
+            return this;
+        }
+
+        public Builder negative_int_value(Long negative_int_value) {
+            this.negative_int_value = negative_int_value;
+            return this;
+        }
+
+        public Builder double_value(Double double_value) {
+            this.double_value = double_value;
+            return this;
+        }
+
+        public Builder string_value(ByteString string_value) {
+            this.string_value = string_value;
+            return this;
+        }
+
+        public Builder aggregate_value(String aggregate_value) {
+            this.aggregate_value = aggregate_value;
+            return this;
+        }
+
+        @Override
+        public UninterpretedOption build() {
+            return new UninterpretedOption(name, identifier_value, positive_int_value, negative_int_value, double_value, string_value, aggregate_value, super.buildUnknownFields());
+        }
+    }
+
+    /**
+     * The name of the uninterpreted option.  Each string represents a segment in
+     * a dot-separated name.  is_extension is true iff a segment represents an
+     * extension (denoted with parentheses in options specs in .proto files).
+     * E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
+     * "foo.(bar.baz).qux".
+     */
+    public static final class NamePart extends Message<NamePart, NamePart.Builder> {
+        public static final ProtoAdapter<NamePart> ADAPTER = new ProtoAdapter_NamePart();
+        public static final String DEFAULT_NAME_PART = "";
+        public static final Boolean DEFAULT_IS_EXTENSION = false;
+        private static final long serialVersionUID = 0L;
+        @WireField(
+                tag = 1,
+                adapter = "com.squareup.wire.ProtoAdapter#STRING",
+                label = WireField.Label.REQUIRED
+        )
+        public final String name_part;
+
+        @WireField(
+                tag = 2,
+                adapter = "com.squareup.wire.ProtoAdapter#BOOL",
+                label = WireField.Label.REQUIRED
+        )
+        public final Boolean is_extension;
+
+        public NamePart(String name_part, Boolean is_extension) {
+            this(name_part, is_extension, ByteString.EMPTY);
+        }
+
+        public NamePart(String name_part, Boolean is_extension, ByteString unknownFields) {
+            super(ADAPTER, unknownFields);
+            this.name_part = name_part;
+            this.is_extension = is_extension;
+        }
+
+        @Override
+        public Builder newBuilder() {
+            Builder builder = new Builder();
+            builder.name_part = name_part;
+            builder.is_extension = is_extension;
+            builder.addUnknownFields(unknownFields());
+            return builder;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if (other == this) {
+                return true;
+            }
+            if (!(other instanceof NamePart)) {
+                return false;
+            }
+            NamePart o = (NamePart) other;
+            return unknownFields().equals(o.unknownFields())
+                    && name_part.equals(o.name_part)
+                    && is_extension.equals(o.is_extension);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = super.hashCode;
+            if (result == 0) {
+                result = unknownFields().hashCode();
+                result = result * 37 + name_part.hashCode();
+                result = result * 37 + is_extension.hashCode();
+                super.hashCode = result;
+            }
+            return result;
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder builder = new StringBuilder();
+            builder.append(", name_part=").append(name_part);
+            builder.append(", is_extension=").append(is_extension);
+            return builder.replace(0, 2, "NamePart{").append('}').toString();
+        }
+
+        public static final class Builder extends Message.Builder<NamePart, Builder> {
+            public String name_part;
+
+            public Boolean is_extension;
+
+            public Builder() {
+            }
+
+            public Builder name_part(String name_part) {
+                this.name_part = name_part;
+                return this;
+            }
+
+            public Builder is_extension(Boolean is_extension) {
+                this.is_extension = is_extension;
+                return this;
+            }
+
+            @Override
+            public NamePart build() {
+                if (name_part == null
+                        || is_extension == null) {
+                    throw Internal.missingRequiredFields(name_part, "name_part",
+                            is_extension, "is_extension");
+                }
+                return new NamePart(name_part, is_extension, super.buildUnknownFields());
+            }
+        }
+
+        private static final class ProtoAdapter_NamePart extends ProtoAdapter<NamePart> {
+            public ProtoAdapter_NamePart() {
+                super(FieldEncoding.LENGTH_DELIMITED, NamePart.class);
+            }
+
+            @Override
+            public int encodedSize(NamePart value) {
+                return ProtoAdapter.STRING.encodedSizeWithTag(1, value.name_part)
+                        + ProtoAdapter.BOOL.encodedSizeWithTag(2, value.is_extension)
+                        + value.unknownFields().size();
+            }
+
+            @Override
+            public void encode(ProtoWriter writer, NamePart value) throws IOException {
+                ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name_part);
+                ProtoAdapter.BOOL.encodeWithTag(writer, 2, value.is_extension);
+                writer.writeBytes(value.unknownFields());
+            }
+
+            @Override
+            public NamePart decode(ProtoReader reader) throws IOException {
+                Builder builder = new Builder();
+                long token = reader.beginMessage();
+                for (int tag; (tag = reader.nextTag()) != -1; ) {
+                    switch (tag) {
+                        case 1:
+                            builder.name_part(ProtoAdapter.STRING.decode(reader));
+                            break;
+                        case 2:
+                            builder.is_extension(ProtoAdapter.BOOL.decode(reader));
+                            break;
+                        default: {
+                            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                            builder.addUnknownField(tag, fieldEncoding, value);
+                        }
+                    }
+                }
+                reader.endMessage(token);
+                return builder.build();
+            }
+
+            @Override
+            public NamePart redact(NamePart value) {
+                Builder builder = value.newBuilder();
+                builder.clearUnknownFields();
+                return builder.build();
+            }
+        }
+    }
+
+    private static final class ProtoAdapter_UninterpretedOption extends ProtoAdapter<UninterpretedOption> {
+        public ProtoAdapter_UninterpretedOption() {
+            super(FieldEncoding.LENGTH_DELIMITED, UninterpretedOption.class);
+        }
+
+        @Override
+        public int encodedSize(UninterpretedOption value) {
+            return NamePart.ADAPTER.asRepeated().encodedSizeWithTag(2, value.name)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(3, value.identifier_value)
+                    + ProtoAdapter.UINT64.encodedSizeWithTag(4, value.positive_int_value)
+                    + ProtoAdapter.INT64.encodedSizeWithTag(5, value.negative_int_value)
+                    + ProtoAdapter.DOUBLE.encodedSizeWithTag(6, value.double_value)
+                    + ProtoAdapter.BYTES.encodedSizeWithTag(7, value.string_value)
+                    + ProtoAdapter.STRING.encodedSizeWithTag(8, value.aggregate_value)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, UninterpretedOption value) throws IOException {
+            NamePart.ADAPTER.asRepeated().encodeWithTag(writer, 2, value.name);
+            ProtoAdapter.STRING.encodeWithTag(writer, 3, value.identifier_value);
+            ProtoAdapter.UINT64.encodeWithTag(writer, 4, value.positive_int_value);
+            ProtoAdapter.INT64.encodeWithTag(writer, 5, value.negative_int_value);
+            ProtoAdapter.DOUBLE.encodeWithTag(writer, 6, value.double_value);
+            ProtoAdapter.BYTES.encodeWithTag(writer, 7, value.string_value);
+            ProtoAdapter.STRING.encodeWithTag(writer, 8, value.aggregate_value);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public UninterpretedOption decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 2:
+                        builder.name.add(NamePart.ADAPTER.decode(reader));
+                        break;
+                    case 3:
+                        builder.identifier_value(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    case 4:
+                        builder.positive_int_value(ProtoAdapter.UINT64.decode(reader));
+                        break;
+                    case 5:
+                        builder.negative_int_value(ProtoAdapter.INT64.decode(reader));
+                        break;
+                    case 6:
+                        builder.double_value(ProtoAdapter.DOUBLE.decode(reader));
+                        break;
+                    case 7:
+                        builder.string_value(ProtoAdapter.BYTES.decode(reader));
+                        break;
+                    case 8:
+                        builder.aggregate_value(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public UninterpretedOption redact(UninterpretedOption value) {
+            Builder builder = value.newBuilder();
+            Internal.redactElements(builder.name, NamePart.ADAPTER);
+            builder.clearUnknownFields();
+            return builder.build();
+        }
+    }
+}
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
index 36b3516..e4f62cb 100644
--- a/app/src/main/res/values/strings.xml
+++ b/app/src/main/res/values/strings.xml
@@ -1,6 +1,6 @@
 <resources>
     <string name="app_name">ArchitecturePlayground</string>
-    <string name="transaction_suceeded">Transação concluída!</string>
+    <string name="transaction_suceeded">Transação \'%s\' concluída!</string>
     <string name="transaction_failed">Transação não completada!</string>
     <string name="action_new_sale">Nova venda</string>
     <string name="action_pay">Pagar</string>
diff --git a/build.gradle b/build.gradle
index ef98fcc..8f35538 100644
--- a/build.gradle
+++ b/build.gradle
@@ -7,7 +7,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.3.0-beta04'
+        classpath 'com.android.tools.build:gradle:3.3.0-rc01'
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
         classpath 'org.jacoco:org.jacoco.core:0.8.2'
         classpath 'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.8.4'
diff --git a/version.gradle b/version.gradle
new file mode 100644
index 0000000..cb3fc52
--- /dev/null
+++ b/version.gradle
@@ -0,0 +1,54 @@
+import java.text.SimpleDateFormat
+
+android {
+    defaultConfig {
+        versionCode getVersionCodeNumber()
+        versionName calculateVersion()
+    }
+
+    sourceSets {
+        nightly.java.srcDirs = sourceSets.release.java.srcDirs
+        releaseCandidate.java.srcDirs = sourceSets.release.java.srcDirs
+    }
+
+    buildTypes {
+        nightly.initWith(buildTypes.release)
+        nightly {
+            versionNameSuffix "-NB-${getBuildSuffix()}"
+        }
+        releaseCandidate.initWith(buildTypes.release)
+        releaseCandidate {
+            versionNameSuffix "-RC${getBuildSuffix()}"
+        }
+    }
+}
+
+def getBuildSuffix() {
+    def nowCal = Calendar.instance
+    def dateFormatter = new SimpleDateFormat("MMddHHmm")
+    return '.' + dateFormatter.format(nowCal.time)
+}
+
+
+def calculateVersion() {
+    Properties data = loadVersionFile()
+    def revision = Integer.parseInt(data['FIX'])
+    def minor = Integer.parseInt(data['MINOR'])
+    def major = Integer.parseInt(data['MAJOR'])
+    return "$major.$minor${revision > 0 ? '.' + revision : ''}"
+}
+
+def getVersionCodeNumber() {
+    return Integer.parseInt(loadVersionFile()['NUMBER'])
+}
+
+def loadVersionFile() {
+    def versionPropsFile = file("$project.rootDir/version.properties")
+    if (versionPropsFile.canRead()) {
+        Properties versionProps = new Properties()
+        versionProps.load(new FileInputStream(versionPropsFile))
+        return versionProps
+    } else {
+        throw new Exception("Could not read version.properties!")
+    }
+}
\ No newline at end of file
diff --git a/version.properties b/version.properties
new file mode 100644
index 0000000..4e0f3e6
--- /dev/null
+++ b/version.properties
@@ -0,0 +1,4 @@
+MAJOR=1
+MINOR=0
+FIX=1
+NUMBER=1
\ No newline at end of file
